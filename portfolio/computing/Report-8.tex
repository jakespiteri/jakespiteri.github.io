\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
            pdftitle={Portfolio Report 8: Matrices},
            pdfauthor={Jake Spiteri},
            colorlinks=true,
            linkcolor=Maroon,
            filecolor=Maroon,
            citecolor=Blue,
            urlcolor=blue,
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\title{Portfolio Report 8: Matrices}
\author{Jake Spiteri}
\date{2019}

\begin{document}
\maketitle

\hypertarget{matrices}{%
\section{Matrices}\label{matrices}}

In this report we will look at how \texttt{R} treats matrices.

We will explore the \texttt{Matrix} package, which extends the basic
\texttt{R} functionality for matrices. For example, it seems odd that
base \texttt{R} does not have a method of determining the rank of a
matrix up to a certain tolerance --- the \texttt{Matrix} package adds
this functionality.

\hypertarget{dense-matrices}{%
\subsection{Dense matrices}\label{dense-matrices}}

A matrix is a two dimensional data structure in \texttt{R}. We specify a
matrix by its columns, and we can change this default functionality by
setting \texttt{byrow=T}. We can assign names to the rows and columns of
a matrix, and easily change these names by redefining
\texttt{colnames(\textless{}matrix\textgreater{})} and
\texttt{rownames(\textless{}matrix\textgreater{})}. This is shown below.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# matrices are defined by columns}
\NormalTok{m <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# print the class of the matrix object}
\KeywordTok{class}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "matrix"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# we can observe attributes}
\KeywordTok{attributes}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $dim
## [1] 2 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# we can print this attribute}
\KeywordTok{dim}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# we can assign row and column names when creating the matrix}
\NormalTok{m <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{), }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)), }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{, }
            \DataTypeTok{dimnames =} \KeywordTok{list}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"obs 1"}\NormalTok{, }\StringTok{"obs 2"}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\StringTok{"r.v. 1"}\NormalTok{, }\StringTok{"r.v. 2"}\NormalTok{)))}
\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           r.v. 1    r.v. 2
## obs 1 -0.8890308 1.2196586
## obs 2  0.2697414 0.7219776
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# print colnames}
\KeywordTok{colnames}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "r.v. 1" "r.v. 2"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# print rownames}
\KeywordTok{rownames}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "obs 1" "obs 2"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# redefine colnames}
\KeywordTok{colnames}\NormalTok{(m) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"new col name 1"}\NormalTok{, }\StringTok{"new col name 2"}\NormalTok{)}

\CommentTok{# redefine rownames}
\KeywordTok{rownames}\NormalTok{(m) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"new row name 1"}\NormalTok{, }\StringTok{"new row name 2"}\NormalTok{)}

\CommentTok{# print new matrix}
\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                new col name 1 new col name 2
## new row name 1     -0.8890308      1.2196586
## new row name 2      0.2697414      0.7219776
\end{verbatim}

It's quite odd but when we select a row or column of a matrix,
\texttt{R} returns a vector and loses the matrix dimensions. When
selecting a row of a \(2 \times 2\) matrix we would expect a vector of
dimension \(1 \times 2\).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# select row}
\NormalTok{m[}\DecValTok{1}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## new col name 1 new col name 2 
##     -0.8890308      1.2196586
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# check dimensions of row}
\KeywordTok{dim}\NormalTok{(m[}\DecValTok{1}\NormalTok{,])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## NULL
\end{verbatim}

In order to change this behavior, we can specify \texttt{drop=F}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# select row}
\NormalTok{m[}\DecValTok{1}\NormalTok{,,drop=F]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                new col name 1 new col name 2
## new row name 1     -0.8890308       1.219659
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# check dimensions}
\KeywordTok{dim}\NormalTok{(m[}\DecValTok{1}\NormalTok{,,}\DataTypeTok{drop=}\NormalTok{F])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2
\end{verbatim}

This is inconvenient but it allows us to maintain the dimensions of a
matrix when indexing. When selecting a column of a matrix we would
expect to obtain a column vector, but this is also not the case unless
we specify \texttt{drop=F}.

\texttt{R} also has higher-dimensional data structures called arrays. We
can think of an array as stacked matrices. For example, specifying
dimension \texttt{(4,5,6)} creates 6 matrices with 4 rows and 5 columns.

Below we will specify an array of dimension \texttt{(2,2,3)}. Recall
that \texttt{R} specifies a matrix by its columns --- we will
demonstrate this.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arr <-}\StringTok{ }\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{))}

\KeywordTok{dim}\NormalTok{(arr)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 2 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arr[,,}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arr[,,}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    2    1
## [2,]    3    2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arr[,,}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    3    2
## [2,]    1    3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# We can also select the rows or columns}
\NormalTok{arr[}\DecValTok{1}\NormalTok{,,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    3    1    2
\end{verbatim}

Note in the above that when we do \texttt{arr{[}1,,{]}} this selects the
first row of each matrix, which are \((1,3)\), \((2,1)\), and \((3,2)\),
and puts them into a matrix.

\hypertarget{solving-linear-systems}{%
\subsection{Solving linear systems}\label{solving-linear-systems}}

A common problem encountered in linear algebra is solving a system of
linear equations. That is, finding \(x\) that solves \(Ax = b\). On
paper we would simply write \(x = A^{-1}b\). There are two ways of
implementing this solution in \texttt{R}: we could use
\texttt{x\ \textless{}-\ solve(A)\ \%*\%\ b}; we could directly solve
the system using \texttt{x\ =\ solve(A,\ b)}. Naturally we would expect
these solutions to be equal, but this is not necessarily the case in
\texttt{R}. We shall show this by an example with Hilbert matrices which
are well known to be close to singular.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A <-}\StringTok{ }\KeywordTok{as.matrix}\NormalTok{(}\KeywordTok{Hilbert}\NormalTok{(}\DecValTok{9}\NormalTok{))}

\CommentTok{# finding the rank is inconsistent}
\KeywordTok{rankMatrix}\NormalTok{(A)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
## attr(,"method")
## [1] "tolNorm2"
## attr(,"useGrad")
## [1] FALSE
## attr(,"tol")
## [1] 1.998401e-15
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rankMatrix}\NormalTok{(A, }\DataTypeTok{tol =} \FloatTok{1e-9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7
## attr(,"method")
## [1] "tolNorm2"
## attr(,"useGrad")
## [1] FALSE
## attr(,"tol")
## [1] 1e-09
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# show nearly singular}
\KeywordTok{det}\NormalTok{(A)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9.720256e-43
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# create a linear system}
\NormalTok{x <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{9}\NormalTok{), }\DecValTok{9}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{b <-}\StringTok{ }\NormalTok{A }\OperatorTok{%*%}\StringTok{ }\NormalTok{x}

\CommentTok{# solve}
\NormalTok{x1 <-}\StringTok{ }\KeywordTok{solve}\NormalTok{(A) }\OperatorTok{%*%}\StringTok{ }\NormalTok{b}
\NormalTok{x2 <-}\StringTok{ }\KeywordTok{solve}\NormalTok{(A, b)}

\CommentTok{# compute some metric of the error}
\KeywordTok{norm}\NormalTok{(x}\OperatorTok{-}\NormalTok{x1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.0001425924
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{norm}\NormalTok{(x}\OperatorTok{-}\NormalTok{x2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3.41572e-05
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# compare the residuals}
\KeywordTok{norm}\NormalTok{(b }\OperatorTok{-}\StringTok{ }\NormalTok{A }\OperatorTok{%*%}\StringTok{ }\NormalTok{x1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.532503e-06
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{norm}\NormalTok{(b }\OperatorTok{-}\StringTok{ }\NormalTok{A }\OperatorTok{%*%}\StringTok{ }\NormalTok{x2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.665335e-16
\end{verbatim}

We see that solving the system of equations directly is far superior,
both in terms of accuracy and speed. In \texttt{R} we should always
avoid directly computing the inverse of a matrix, unless the inverted
matrix will be used multiple times to solve linear systems. Even then,
there are better ways to approach the problem. We can always look at
different decompositions of the matrix and find a more numerically
stable method of solving the linear system. This is what functions such
as \texttt{lm()} do --- they do not directly solve for predicted
coefficients using \(\hat{\beta} = (X^TX)^{-1}X^TY\), they rely on the
QR decomposition. Before we compute the inverse of a matrix we should
try to find a more elegant solution by decomposing the matrices
involved.

\hypertarget{numerical-stability-and-finite-precision-arithmetic}{%
\subsection{Numerical stability and finite precision
arithmetic}\label{numerical-stability-and-finite-precision-arithmetic}}

In most programming packages, a floating point number is stored as a
`double' precision number. According to the IEEE754 standard a double
number consists of 64 binary bits arranged as follows:

\begin{itemize}
\tightlist
\item
  sign bit: 1 bit
\item
  exponent bit: 11 bits
\item
  significant precision: 52 bits
\end{itemize}

Thus, we are limited in the length of the numbers we can store. This
means there exist smallest and largest numbers in \texttt{R}. We can see
this demonstrated below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{2}\OperatorTok{^}\NormalTok{(}\OperatorTok{-}\DecValTok{1075}\NormalTok{), }\DecValTok{2}\OperatorTok{^}\NormalTok{(}\OperatorTok{-}\DecValTok{1074}\NormalTok{), }\DecValTok{2}\OperatorTok{^}\DecValTok{1023}\NormalTok{, }\DecValTok{2}\OperatorTok{^}\DecValTok{1024}\NormalTok{, }\DecValTok{2}\OperatorTok{^}\DecValTok{1024} \OperatorTok{/}\StringTok{ }\DecValTok{2}\OperatorTok{^}\DecValTok{1024}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  0.000000e+00 4.940656e-324 8.988466e+307           Inf           NaN
\end{verbatim}

We see that \(2^{1023}\) is the largest number that can be stored. Any
higher and \texttt{R} returns \texttt{Inf}. Note that we can no longer
do arithmetic with \texttt{Inf} --- even a simple operation such as
\(2^{1024}/2^{1024}\) cannot be computed.

We have 52 precision bits, so we can expect an error rate of
approximately \(10^{-16}\) (\(2^{-52} \approx 2.22 \times 10^{-16}\)) in
numerical computations of double numbers. This is shown below. The
\texttt{R} documentation mentions that we should avoid using more than
15 digits.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# R will not suggest digits >= 16}
\CommentTok{# so if we add a very small number to 1, it will not print}
\KeywordTok{print}\NormalTok{(}\DecValTok{1} \OperatorTok{+}\StringTok{ }\FloatTok{1e-14}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# specify digits}
\KeywordTok{print}\NormalTok{(}\DecValTok{1} \OperatorTok{+}\StringTok{ }\FloatTok{1e-14}\NormalTok{, }\DataTypeTok{digits=}\DecValTok{15}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1.00000000000001
\end{verbatim}

These numerical characteristics of the machine are also stored in
\texttt{R}. We can access them using \texttt{.Machine}. For example, we
can find the smallest \(x\) such that \(1 + x \neq 1\) (the machine
epsilon) using \texttt{.Machine\$double.eps}. \texttt{.Machine} stores
many interesting characteristics and is definitely worth exploring.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# }
\NormalTok{.Machine}\OperatorTok{$}\NormalTok{double.eps}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.220446e-16
\end{verbatim}

Arithmetic with double floating point numbers is not so easy in
\texttt{R}. This is because of numerical errors --- this is a problem
for even trivial calculations as shown below. These errors occur because
floating points can only represent the dyadic rationals, which are
numbers with denominators which are powers of 2. Hence 0.1 is simply
approximated as a dyadic rational. This leads to unexpected results, for
example, \texttt{0.1+0.2\ ==\ 0.3} is \texttt{FALSE}!

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# not zero}
\FloatTok{0.1+0.2-0.3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5.551115e-17
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# looks okay}
\FloatTok{0.1} \OperatorTok{+}\StringTok{ }\FloatTok{0.2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# check}
\FloatTok{0.1} \OperatorTok{+}\StringTok{ }\FloatTok{0.2} \OperatorTok{==}\StringTok{ }\FloatTok{0.3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# all.equal uses a tolerance parameter}
\KeywordTok{all.equal}\NormalTok{(}\FloatTok{0.1} \OperatorTok{+}\StringTok{ }\FloatTok{0.2}\NormalTok{, }\FloatTok{0.3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

We see that the equality comparison \texttt{==} often does not behave
the way we expect it to. When working with double floating point numbers
we should avoid testing equality using \texttt{==} and instead use
\texttt{all.equal()} which ignores machine errors using a tolerance
parameter.

\texttt{R} also has an integer data type `long'.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# 1L seems to be the same as 1}
\NormalTok{1L}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# test equality}
\DecValTok{1} \OperatorTok{==}\StringTok{ }\NormalTok{1L}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{identical}\NormalTok{(}\DecValTok{1}\NormalTok{, 1L)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Given that error is introduced with arithmetic operations, the errors
produced by matrix multiplication are much larger due to the numerous
operations of addition and scalar multiplication.

Suppose we have matrices \(A \in \mathbb{R}^{n \times n}\),
\(B \in \mathbb{R}^{n \times m}\), and
\(C \in \mathbb{R}^{m \times 1}\). Then the flop cost of computing
\(AB\) is of the order \(\mathcal{O}(n^2m)\) as it requires \(n^2m\)
multiplications. The flop cost of computing \(BC\) is of the order
\(\mathcal{O}(nm)\). Let \(m=n\), then to compute \(ABC\) has cost of
the order \(\mathcal{O}(n^3)\) and to compute \(A(BC)\) has cost of the
order \(\mathcal{O}(n^2)\). Thus, whilst these quantities are the same
algebraically, the order of multiplications impacts the number of
multiplications and thus impacts the error produced. In the following
example we expect computing \(ABC\) to have an error approximately
\(10\) times larger than computing \(A(BC)\).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# check error for matrix addition and subtraction}
\NormalTok{A <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{100}\NormalTok{),}\DecValTok{10}\NormalTok{,}\DecValTok{10}\NormalTok{); B <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{100}\NormalTok{),}\DecValTok{10}\NormalTok{,}\DecValTok{10}\NormalTok{); C <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\KeywordTok{summary}\NormalTok{(}\KeywordTok{c}\NormalTok{((A }\OperatorTok{+}\StringTok{ }\NormalTok{B) }\OperatorTok{-}\StringTok{ }\NormalTok{A }\OperatorTok{-}\StringTok{ }\NormalTok{B))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       Min.    1st Qu.     Median       Mean    3rd Qu.       Max. 
## -4.441e-16  0.000e+00  0.000e+00 -1.023e-18  0.000e+00  4.441e-16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# check error for matrix multiplication}
\KeywordTok{summary}\NormalTok{(}\KeywordTok{c}\NormalTok{(A}\OperatorTok{%*%}\NormalTok{B}\OperatorTok{%*%}\NormalTok{C }\OperatorTok{-}\StringTok{ }\NormalTok{A}\OperatorTok{%*%}\NormalTok{(B}\OperatorTok{%*%}\NormalTok{C)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       Min.    1st Qu.     Median       Mean    3rd Qu.       Max. 
## -7.105e-15 -8.882e-16  6.661e-16 -8.882e-17  2.109e-15  3.553e-15
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# check computation times}
\NormalTok{n <-}\StringTok{ }\DecValTok{5000}
\NormalTok{A <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(n}\OperatorTok{^}\DecValTok{2}\NormalTok{), n, n); B <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(n}\OperatorTok{^}\DecValTok{2}\NormalTok{), n, n); C <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(n)}
\KeywordTok{c}\NormalTok{(}\KeywordTok{system.time}\NormalTok{(A}\OperatorTok{%*%}\NormalTok{B}\OperatorTok{%*%}\NormalTok{C), }\KeywordTok{system.time}\NormalTok{(A}\OperatorTok{%*%}\NormalTok{(B}\OperatorTok{%*%}\NormalTok{C)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  user.self   sys.self    elapsed user.child  sys.child  user.self   sys.self 
##     33.961      3.784      6.741      0.000      0.000      0.506      0.179 
##    elapsed user.child  sys.child 
##      0.143      0.000      0.000
\end{verbatim}

When working with matrices we must think carefully about what we are
trying to do, in order to avoid unnecessary multiplications which can
introduce numerical errors.

Suppose we want to sum the diagonal entries of the matrix product
\(AB\), for \(A \in \mathbb{R}^{n \times m}\),
\(B \in \mathbb{R}^{m \times n}\) where \(m << n\). Note the costs of
forming \(AB\) compared to \(BA\) (\(\mathcal{O}(n^2m)\) compared to
\(\mathcal{O}(m^2n)\)). In \texttt{R} there are multiple ways we can do
this.

\begin{itemize}
\item
  We can compute the matrix product \(AB\), extract the diagonal
  entries, and sum them.
\item
  We can instead compute the matrix product \(BA\), extract the diagonal
  entries, and sum them. This uses the fact that
  \(\text{tr}(AB) = \text{tr}(BA)\).
\item
  We can sum the elements of \(A * B^T\) (element-wise multiplication),
  since \(\text{tr} = \sum_{i,j} A_{ij} B_{ji}\).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\DecValTok{10000}\NormalTok{; m <-}\StringTok{ }\DecValTok{1000}
\NormalTok{A <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(n}\OperatorTok{*}\NormalTok{m), n, m); B <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(n}\OperatorTok{*}\NormalTok{m), m, n)}

\CommentTok{# first, second, and third method}
\NormalTok{first <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(}\KeywordTok{diag}\NormalTok{(A }\OperatorTok{%*%}\StringTok{ }\NormalTok{B))}
\NormalTok{second <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(}\KeywordTok{diag}\NormalTok{(B }\OperatorTok{%*%}\StringTok{ }\NormalTok{A))}
\NormalTok{third <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(A }\OperatorTok{*}\StringTok{ }\KeywordTok{t}\NormalTok{(B))}

\CommentTok{# compare errors}
\KeywordTok{summary}\NormalTok{(first }\OperatorTok{-}\StringTok{ }\NormalTok{second)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
## 1.819e-12 1.819e-12 1.819e-12 1.819e-12 1.819e-12 1.819e-12
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(first }\OperatorTok{-}\StringTok{ }\NormalTok{third)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
## 1.819e-12 1.819e-12 1.819e-12 1.819e-12 1.819e-12 1.819e-12
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(second }\OperatorTok{-}\StringTok{ }\NormalTok{third)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##       0       0       0       0       0       0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# compare computation time}
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{sum}\NormalTok{(}\KeywordTok{diag}\NormalTok{(A }\OperatorTok{%*%}\StringTok{ }\NormalTok{B))) }\CommentTok{# first}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    user  system elapsed 
##  34.137   2.913   6.773
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{sum}\NormalTok{(}\KeywordTok{diag}\NormalTok{(B }\OperatorTok{%*%}\StringTok{ }\NormalTok{A))) }\CommentTok{# second}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    user  system elapsed 
##   2.656   0.687   0.549
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{system.time}\NormalTok{(}\KeywordTok{sum}\NormalTok{(A }\OperatorTok{*}\StringTok{ }\KeywordTok{t}\NormalTok{(B)))      }\CommentTok{# third}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    user  system elapsed 
##    0.23    0.06    0.29
\end{verbatim}

The second method is much better than the first both in terms of
precision and run time. The third method is better than the second
method.

\hypertarget{sparse-matrices}{%
\subsection{Sparse Matrices}\label{sparse-matrices}}

The R packages \texttt{Matrix} provides additional functionality for
both dense matrices and sparse matrices. In the \texttt{Matrix}
packages, dense matrices are stored as \texttt{dgeMatrix} objects, and
sparse matrices are stored as \texttt{dgCMatrix} objects. A useful
function we have already seen is \texttt{rankMatrix} which provides the
rank of the input matrix up to a certain tolerance.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(Matrix)}
\NormalTok{A <-}\StringTok{ }\KeywordTok{Matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{),}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\NormalTok{B <-}\StringTok{ }\KeywordTok{Matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{/}\FloatTok{1e10}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{)}

\KeywordTok{c}\NormalTok{(}\KeywordTok{rankMatrix}\NormalTok{(A), }\KeywordTok{rankMatrix}\NormalTok{(B), }\KeywordTok{rankMatrix}\NormalTok{(B, }\DataTypeTok{tol=}\FloatTok{1e-7}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 1
\end{verbatim}

A sparse matrix is one in which most entries are equal to zero. It's
inefficient to store all of these zeros in memory, and so we only store
the non-zero entries.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{25}\NormalTok{)}
\NormalTok{nrows <-}\StringTok{ }\NormalTok{ncols <-}\StringTok{ }\DecValTok{500}
\NormalTok{entries <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{),nrows}\OperatorTok{*}\NormalTok{ncols,}\OtherTok{TRUE}\NormalTok{,}\KeywordTok{c}\NormalTok{(}\FloatTok{0.98}\NormalTok{, }\FloatTok{0.01}\NormalTok{, }\FloatTok{0.01}\NormalTok{))}
\NormalTok{m1 <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(entries, nrows, ncols)}
\NormalTok{m2 <-}\StringTok{ }\KeywordTok{Matrix}\NormalTok{(entries, nrows, ncols, }\DataTypeTok{sparse =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{c}\NormalTok{(}\KeywordTok{class}\NormalTok{(m1), }\KeywordTok{class}\NormalTok{(m2))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "matrix"    "dgCMatrix"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m1[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{,}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## [1,]    0    0    0    0    0    0    0    0    0     0
## [2,]    0    1    0    0    0    0    0    0    0     1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m2[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{,}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2 x 10 sparse Matrix of class "dgCMatrix"
##                         
## [1,] . . . . . . . . . .
## [2,] . 1 . . . . . . . 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\KeywordTok{object.size}\NormalTok{(m1), }\KeywordTok{object.size}\NormalTok{(m2))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2000216   62904
\end{verbatim}

We see that a sparse matrix defined using the \texttt{Matrix} package
has class \texttt{dgCMatrix}. The `d' stands for digit, the `g' stands
for general, and the `C' stands for column. We can convert a
\texttt{dgCMatrix} to a \texttt{dgeMatrix} --- the standard class for
dense matrices --- but we will lose the memory improvements of the
compressed sparse format. Alternatives to the \texttt{dgCMatrix} are the
\texttt{dgRMatrix} and \texttt{dgTMatrix} classes. We can convert a
\texttt{dgCMatrix} into a \texttt{dgTMatrix} (a triplet matrix), but not
a \texttt{dgRMatrix}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# display the structure}
\KeywordTok{str}\NormalTok{(m2, }\DataTypeTok{max.level =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Formal class 'dgCMatrix' [package "Matrix"] with 6 slots
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(m2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Formal class 'dgCMatrix' [package "Matrix"] with 6 slots
##   ..@ i       : int [1:4950] 5 46 141 211 315 327 380 430 482 485 ...
##   ..@ p       : int [1:501] 0 10 21 29 42 47 54 58 67 76 ...
##   ..@ Dim     : int [1:2] 500 500
##   ..@ Dimnames:List of 2
##   .. ..$ : NULL
##   .. ..$ : NULL
##   ..@ x       : num [1:4950] 2 1 1 1 1 1 1 1 1 1 ...
##   ..@ factors : list()
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{which}\NormalTok{(m2[,}\DecValTok{1}\NormalTok{]}\OperatorTok{>}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]   6  47 142 212 316 328 381 431 483 486
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# show difference in memory size}
\KeywordTok{object.size}\NormalTok{(}\KeywordTok{as}\NormalTok{(m2, }\StringTok{'dgeMatrix'}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2001176 bytes
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{object.size}\NormalTok{(}\KeywordTok{as}\NormalTok{(m2, }\StringTok{'dgTMatrix'}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 80696 bytes
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{object.size}\NormalTok{(m2) }\CommentTok{# dgCMatrix}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 62904 bytes
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# print the matrices before and after coercion}
\NormalTok{m2[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{] }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2 x 10 sparse Matrix of class "dgCMatrix"
##                         
## [1,] . . . . . . . . . .
## [2,] . 1 . . . . . . . 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as}\NormalTok{(m2, }\StringTok{'dgTMatrix'}\NormalTok{)[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 2 x 10 sparse Matrix of class "dgTMatrix"
##                         
## [1,] . . . . . . . . . .
## [2,] . 1 . . . . . . . 1
\end{verbatim}

\hypertarget{operations-for-sparse-matrices}{%
\subsubsection{Operations for sparse
matrices}\label{operations-for-sparse-matrices}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A <-}\StringTok{ }\NormalTok{B <-}\StringTok{ }\KeywordTok{Matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{),}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{, }\DataTypeTok{sparse=}\OtherTok{TRUE}\NormalTok{)}
\NormalTok{A}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 3 x 2 sparse Matrix of class "dgCMatrix"
##         
## [1,] 1 .
## [2,] 1 .
## [3,] . 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# division maintains class}
\NormalTok{A}\OperatorTok{/}\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 3 x 2 sparse Matrix of class "dgCMatrix"
##             
## [1,] 0.1 .  
## [2,] 0.1 .  
## [3,] .   0.1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# addition and subtraction change class to dgeMatrix}
\NormalTok{A}\OperatorTok{+}\DecValTok{1}\NormalTok{; A}\DecValTok{-1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 3 x 2 Matrix of class "dgeMatrix"
##      [,1] [,2]
## [1,]    2    1
## [2,]    2    1
## [3,]    1    2
\end{verbatim}

\begin{verbatim}
## 3 x 2 Matrix of class "dgeMatrix"
##      [,1] [,2]
## [1,]    0   -1
## [2,]    0   -1
## [3,]   -1    0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# matrix multiplication changes class}
\NormalTok{A }\OperatorTok{%*%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 3 x 1 Matrix of class "dgeMatrix"
##      [,1]
## [1,]    1
## [2,]    1
## [3,]    1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# addition and subtraction of two dgCMatrix objects produces an object of the same class}
\NormalTok{A}\OperatorTok{+}\NormalTok{B; A}\OperatorTok{-}\NormalTok{B}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 3 x 2 sparse Matrix of class "dgCMatrix"
##         
## [1,] 2 .
## [2,] 2 .
## [3,] . 2
\end{verbatim}

\begin{verbatim}
## 3 x 2 sparse Matrix of class "dgCMatrix"
##         
## [1,] 0 .
## [2,] 0 .
## [3,] . 0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# matrix multiplication of two dgCMatrix objects gives a dgCMatrix object}
\NormalTok{A }\OperatorTok{%*%}\StringTok{ }\KeywordTok{t}\NormalTok{(B)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 3 x 3 sparse Matrix of class "dgCMatrix"
##           
## [1,] 1 1 .
## [2,] 1 1 .
## [3,] . . 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# row or column binding dgCMatrix objects returns a dgCMatrix}
\KeywordTok{cbind}\NormalTok{(A,A); }\KeywordTok{rbind}\NormalTok{(A,A)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 3 x 4 sparse Matrix of class "dgCMatrix"
##             
## [1,] 1 . 1 .
## [2,] 1 . 1 .
## [3,] . 1 . 1
\end{verbatim}

\begin{verbatim}
## 6 x 2 sparse Matrix of class "dgCMatrix"
##         
## [1,] 1 .
## [2,] 1 .
## [3,] . 1
## [4,] 1 .
## [5,] 1 .
## [6,] . 1
\end{verbatim}

\hypertarget{solving-large-linear-systems}{%
\subsubsection{Solving large linear
systems}\label{solving-large-linear-systems}}

Solving linear systems for very large and sparse systems is very
difficult, as the inverse of a sparse matrix is not necessarily sparse.
To avoid these problems we should directly solve the linear system using
\texttt{solve(A,\ b)}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nrow <-}\StringTok{ }\NormalTok{ncol <-}\StringTok{ }\DecValTok{500}
\NormalTok{A <-}\StringTok{ }\KeywordTok{Matrix}\NormalTok{(}\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{), nrow}\OperatorTok{*}\NormalTok{ncol, }\OtherTok{TRUE}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\FloatTok{0.98}\NormalTok{, }\FloatTok{0.02}\NormalTok{)), nrow, ncol, }\DataTypeTok{sparse=}\OtherTok{TRUE}\NormalTok{)}
\NormalTok{A.inv <-}\StringTok{ }\KeywordTok{solve}\NormalTok{(A)}

\CommentTok{# object sizes}
\KeywordTok{c}\NormalTok{(}\KeywordTok{object.size}\NormalTok{(A), }\KeywordTok{object.size}\NormalTok{(A.inv))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1884440 2001176
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# possible elements}
\NormalTok{nrow}\OperatorTok{*}\NormalTok{ncol}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 250000
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# entries in A}
\KeywordTok{nnzero}\NormalTok{(A)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4897
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# entries in A.inv}
\KeywordTok{nnzero}\NormalTok{(A.inv)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 250000
\end{verbatim}

\end{document}
