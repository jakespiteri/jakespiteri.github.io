<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Portfolio Report 5: Functional and object-oriented programming | Jake Spiteri</title><meta name=keywords content><meta name=description content="Programming paradigms R supports multiple programming paradigms. Programming paradigms describe the way in which code is written and structured for larger projects. The types of programming structures are:
Imperative programming — We define a sequence of instructions that modify the ‘state’ of the program. Object-oriented programming — Objects combine the machine’s state with a set of methods. Programs are then defined via the construction of objects. Declarative programming — A sequence of operations is defined that only specify what the output of the program should be."><meta name=author content="Jake Spiteri"><link rel=canonical href=https://jakespiteri.co.uk/portfolio/computing-1/report-5/><meta name=google-site-verification content="XYZabc"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link crossorigin=anonymous href=/assets/css/stylesheet.ccdd7c01ba69b30dd10ab397e0d0f0774c08df41d39f6b53e16f862223c92b98.css integrity="sha256-zN18Abppsw3RCrOX4NDwd0wI30HTn2tT4W+GIiPJK5g=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jakespiteri.co.uk/favi.png><link rel=icon type=image/png sizes=16x16 href=https://jakespiteri.co.uk/favi.png><link rel=icon type=image/png sizes=32x32 href=https://jakespiteri.co.uk/favi.png><link rel=apple-touch-icon href=https://jakespiteri.co.uk/favi.png><link rel=mask-icon href=https://jakespiteri.co.uk/favi.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Portfolio Report 5: Functional and object-oriented programming"><meta property="og:description" content="Programming paradigms R supports multiple programming paradigms. Programming paradigms describe the way in which code is written and structured for larger projects. The types of programming structures are:
Imperative programming — We define a sequence of instructions that modify the ‘state’ of the program. Object-oriented programming — Objects combine the machine’s state with a set of methods. Programs are then defined via the construction of objects. Declarative programming — A sequence of operations is defined that only specify what the output of the program should be."><meta property="og:type" content="article"><meta property="og:url" content="https://jakespiteri.co.uk/portfolio/computing-1/report-5/"><meta property="og:image" content="https://jakespiteri.co.uk/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="portfolio"><meta property="og:site_name" content="Jake Spiteri"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jakespiteri.co.uk/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Portfolio Report 5: Functional and object-oriented programming"><meta name=twitter:description content="Programming paradigms R supports multiple programming paradigms. Programming paradigms describe the way in which code is written and structured for larger projects. The types of programming structures are:
Imperative programming — We define a sequence of instructions that modify the ‘state’ of the program. Object-oriented programming — Objects combine the machine’s state with a set of methods. Programs are then defined via the construction of objects. Declarative programming — A sequence of operations is defined that only specify what the output of the program should be."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Portfolio","item":"https://jakespiteri.co.uk/portfolio/"},{"@type":"ListItem","position":2,"name":"Statistical Computing 1","item":"https://jakespiteri.co.uk/portfolio/computing-1/"},{"@type":"ListItem","position":3,"name":"Portfolio Report 5: Functional and object-oriented programming","item":"https://jakespiteri.co.uk/portfolio/computing-1/report-5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Portfolio Report 5: Functional and object-oriented programming","name":"Portfolio Report 5: Functional and object-oriented programming","description":"Programming paradigms R supports multiple programming paradigms. Programming paradigms describe the way in which code is written and structured for larger projects. The types of programming structures are:\nImperative programming — We define a sequence of instructions that modify the ‘state’ of the program. Object-oriented programming — Objects combine the machine’s state with a set of methods. Programs are then defined via the construction of objects. Declarative programming — A sequence of operations is defined that only specify what the output of the program should be.","keywords":[],"articleBody":" Programming paradigms R supports multiple programming paradigms. Programming paradigms describe the way in which code is written and structured for larger projects. The types of programming structures are:\nImperative programming — We define a sequence of instructions that modify the ‘state’ of the program. Object-oriented programming — Objects combine the machine’s state with a set of methods. Programs are then defined via the construction of objects. Declarative programming — A sequence of operations is defined that only specify what the output of the program should be. The exact details of how the program is implemented is determined by the programming language. Functional programming — Functions are defined to act identically to mathematical functions. A program is then a sequence of function applications. In this document we will explore the use and applications of functional and object-oriented programming.\nFunctional programming First-class functions R has first-class functions. These are functions that behave like any other data structure. A language has first-class functions if:\nFunctions can be used as arguments to other functions, Functions can be returned by functions, Functions can be stored in data structures. In functional programming we may want to provide a function as an input to another function. We have seen this feature in the Map and Reduce functions in R.\nsquare \u003c- function(x) x*x unlist(Map(square, 1:5)) ## [1] 1 4 9 16 25 Reduce('+', 1:5) ## [1] 15 Reduce('+', unlist(Map(square, 1:5))) ## [1] 55 # we can also use multiple functions within one function Reduce(function(x,y) x*y, unlist(Map(square, 1:5))) ## [1] 14400 We can also take a function as an input, manipulate it, and return it as an output.\nObject-oriented programming Introduction The main reason to use object-oriented programming (OOP) is polymorphism. This provides our functions with reusability and extendability. Polymorphism allows a single object to have multiple methods for various types of input.\nIn OOP, functionality is encapsulated within an object. Every object has a type, which is the class that it belongs to. An implementation for a specific class is called a method. The class defines the fields, which contain the data possessed by every instance of that class. The current state of an object is thus specified by its fields, and its behavior is specified by its methods. If one class is derived from the other, the child class may inherit the fields and methods of the parent class.\nR implements three different object-oriented systems:\nS3 — An informal implementation of OOP which relies upon common conventions. S4 — A formal rewrite of S3. Reference classes (RC) — Implements encapsulated OOP. In this implementation objects are mutable. That is, objects are modified in place. In this report we will look at the S3 and S4 systems.\nS3 S3 is the simplest and most informal system for OOP in R. S3 does not use formal class definitions. It offers an extremely flexible system, which may allow you to do certain things which are not recommended. Since S3 has few built-in constraints, we will outline best practices here.\nAn S3 object is an object of a base type with the attribute class set to the class name. It will be good practice to have a constructor function which can be called to initialize all relevant elements of the object, and then return the object. We may also require a validator which checks our arguments within a separate function. A helper function is also useful for end users that makes the constructor more user-friendly.\nBelow we will implement linear regression as an S3 object.\n# we set the seed for reproducibility set.seed(1) # create a dataset n \u003c- 100 w \u003c- matrix(c(2, -1), ncol=1) X \u003c- rbind(rnorm(100,0,1), rep(1,n)) y \u003c- t(w)%*%X + rnorm(100, 0, 1) plot(X[1,], y[1,]) # we now define a constructor which will return an object of a specified class # the constructor does some operations # encapsulates data in the object # assigns a class to the object # returns the object simple_lin_regression \u003c- function(X, y) { # compute the OLS parameter estimates w_hat \u003c- solve(X%*%t(X))%*%X%*%t(y) # the object encapsulates (X, y, and w_hat) slr \u003c- list(response = as.numeric(y), regressor = X, param_estimate = w_hat) # we declare the object 'slr' to be an S3 object of class \"simple_lin_regression\" class(slr) \u003c- \"simple_lin_regression\" return(slr) } slr \u003c- simple_lin_regression(X, y) Given the above class simple_lin_regression, we will define some methods for the class. To define a method in S3, a generic function of the same name needs to already exist. If it doesn’t already exist we can easily declare a new generic function.\nWe define a new method as a function with function name [method_name].[class_name].\nWe implement a print method which prints relevant information about the object such as the estimated coefficients, and we implement a plot method. Note that print and plot are already generic methods in R and so we do not need to define them as such here.\nprint.simple_lin_regression \u003c- function(x, ...) { cat(\"head(x) =\", head(x$regressor[1,]), \"\\n\") cat(\"head(y) =\", head(x$response), \"\\n\") cat(\"Estimated regression: E[y|x] = b0 + b1*x\\n\") cat(\"b0 = \", x$param_estimate[1,1], \", b1 = \", x$param_estimate[2,1], \".\\n\", sep=\"\") } plot.simple_lin_regression \u003c- function(x, ...) { plot(x$regressor[1,], slr$response, xlab=expression(X), ylab=expression(Y) ) abline(a = x$param_estimate[2], b = x$param_estimate[1], col = \"red\") } Let’s use the methods we defined above. The correct syntax is [method_name](object]).\nprint(slr) ## head(x) = -0.6264538 0.1836433 -0.8356286 1.595281 0.3295078 -0.8204684 ## head(y) = -2.873274 -0.5905975 -3.582179 2.34859 -0.9955691 -0.8736495 ## Estimated regression: E[y|x] = b0 + b1*x ## b0 = 1.99894, b1 = -1.037693. plot(slr) We want to define a method called residual_analysis. In order to do this we must define a generic method with the same name.\n# define the generic method residual_analysis \u003c- function(x){ UseMethod(\"residual_analysis\") } # implement the method for class residual_analysis.simple_lin_regression \u003c- function(x) { predictions \u003c- t(x$param_estimate) %*% X plot(predictions, x$response - predictions, main = \"Residual analysis\", xlab = expression(hat(Y)), ylab = expression(Y-hat(Y))) } residual_analysis(slr) In S3, classes can inherit methods from their parent classes. This is demonstrated below. Note that we can create classes on the fly — we not need to formally define them. We simply define an object and then assign its class.\nP \u003c- structure(numeric(), class = \"parent_class\") C \u003c- structure(numeric(), class = c(\"child_class\", \"parent_class\")) print.parent_class \u003c- function(x) { cat(\"This method belongs to the parent class\") } We check that the method works for both P and C.\nprint(P) ## This method belongs to the parent class print(C) ## This method belongs to the parent class We now provide the child_class class with its own print method.\nprint.child_class \u003c- function(x) { cat(\"This method belongs to the child class\") } print(C) ## This method belongs to the child class print(P) ## This method belongs to the parent class print(C) ## This method belongs to the child class S4 S4 implements a more formal approach to OOP. Unlike S3, all OOP relevant elements must be defined explicitly. S4 provides specialized functions for defining elements such as setClass(), setGeneric(), and setMethod(). While this requires more effort, it provides more clarity and allows us to use built-in integrity checks.\nWe repeat the linear regression task.\nlibrary(methods) We must first create the simple_lin_regression class. We must give it the name of the class being defined, and the slots which represent the fields’ names and types. Slots can be accessed using the specialized subsetting operator @, however we should avoid using this outside of methods in order to provide encapsulation. In order to obtain or change an object’s components we should use getter and setter methods which we define.\nsetClass(\"simple_lin_regression\", slots = c( response = \"numeric\", regressor = \"numeric\", estimate = \"numeric\" ) ) We can instantiate a new object in the class using new(). We create a constructor so that the end user does not have to use the new function.\nsimple_lin_regression \u003c- function(X,y) { slr \u003c- new(\"simple_lin_regression\", response = y, regressor = X) return(slr) } We quickly test that our constructor function works for our generated data.\nslr \u003c- simple_lin_regression(X[1,1:5],y[1,1:5]) slr ## An object of class \"simple_lin_regression\" ## Slot \"response\": ## [1] -2.8732743 -0.5905975 -3.5821789 2.3485904 -0.9955691 ## ## Slot \"regressor\": ## [1] -0.6264538 0.1836433 -0.8356286 1.5952808 0.3295078 ## ## Slot \"estimate\": ## numeric(0) Note that the slot for estimate exists but we have not given it a value yet. It is currently numeric(0). We will create an initialization method that will compute the estimate when we create an object.\nsetMethod(\"initialize\", \"simple_lin_regression\", function(.Object, response, regressor) { .Object@response \u003c- response .Object@regressor \u003c- regressor n \u003c- length(response) X \u003c- rbind(regressor, rep(1,n)) w_hat \u003c- solve(X%*%t(X))%*%X %*% response .Object@estimate \u003c- as.numeric(w_hat) return(.Object) }) When we use the function new() we see that it calls a non-standard generic function initialize(). We can define a custom initialize method that assigns values (such as default values) to an object’s components. We can also perform a computation like above and set its output to one of the object’s components. The first two arguments in the above specify the method initialize, and the class for which it is defined for simple_lin_regression. It returns the object .Object with the components it has been assigned.\nSimilar to what we did for S3, we implement print and pot functions for S4. Recall that in order to access the components of our object we must use the @ operator.\nsetMethod(\"print\", \"simple_lin_regression\", function(x, ...) { cat(\"head(x) =\", head(x@regressor), \"\\n\") cat(\"head(y) =\", head(x@response), \"\\n\\n\") cat(\"Estimated regression: E[y|x] = b0 + b1 * x\\n\") cat(\"b0 = \", x@estimate[1], \" and b1 = \", x@estimate[2], \".\\n\", sep = \"\") } ) setMethod(\"plot\", \"simple_lin_regression\", function(x, y = NULL, ...) { plot(x = x@regressor, y = x@response, xlab = expression(X), ylab = expression(Y)) abline(a = x@estimate[2], b = x@estimate[1], col = \"red\") } ) slr \u003c- simple_lin_regression(X[1,], y[1,]) print(slr) ## head(x) = -0.6264538 0.1836433 -0.8356286 1.595281 0.3295078 -0.8204684 ## head(y) = -2.873274 -0.5905975 -3.582179 2.34859 -0.9955691 -0.8736495 ## ## Estimated regression: E[y|x] = b0 + b1 * x ## b0 = 1.99894 and b1 = -1.037693. plot(slr) Once again, we implement a method called residual_analysis which is a not a generic method and must be defined using setGeneric().\nsetGeneric(\"residual_analysis\") ## [1] \"residual_analysis\" setMethod(\"residual_analysis\", \"simple_lin_regression\", function(x) { predictions \u003c- x@estimate[2] + x@estimate[1] * x@regressor plot(x = predictions, y = x@response - predictions, xlab = expression(hat(Y)), ylab = expression(Y - hat(Y))) }) residual_analysis(slr) Monte carlo example of S4 We will implement Monte Carlo integration using S4.\nWe start with the general problem: We want to compute an integral \\[ \\mathbb{E}_f[h(X)] = \\int_\\mathcal{X} h(x) f(x) dx \\] where \\(\\mathcal{X}\\) is the set from which the random variable \\(X\\) takes its values. In order to compute this integral numerically, we are going to generate a sample \\((X_1, \\dots, X_n)\\) from the density \\(f\\) and approximate the integral via the empirical mean \\[ \\bar{h}_n := \\frac{1}{n} \\sum_{i=1}^n h(x_i).\\] This is a logical estimator as \\(\\bar{h}_n \\rightarrow \\mathbb{E}_f[h(X)]\\) as \\(n \\rightarrow \\infty\\) almost surely (by the Strong Law of Large Numbers).\nWe implement the above method in a class called monteCarloIntegration.\nsetClass(\"monteCarloIntegration\", slots = c( func = \"function\", lower_lim = \"numeric\", upper_lim = \"numeric\", estimates = \"numeric\", est_errors = \"numeric\" )) We now create a constructor function.\nmonte_carlo_int \u003c- function(func, lower, upper) { monte_carlo_integral \u003c- new(\"monteCarloIntegration\", func = func, lower_lim = lower, upper_lim = upper) return(monte_carlo_integral) } Let’s test that our constructor works. We are going to integrate the function \\[h(x) := [\\cos(10x) + sin(4x)]^3\\] over [0,1].\nh \u003c- function(x) {(cos(10*x) + sin(4*x))^3} integral \u003c- monte_carlo_int(h, 0, 1) integral ## An object of class \"monteCarloIntegration\" ## Slot \"func\": ## function(x) {(cos(10*x) + sin(4*x))^3} ## ## Slot \"lower_lim\": ## [1] 0 ## ## Slot \"upper_lim\": ## [1] 1 ## ## Slot \"estimates\": ## numeric(0) ## ## Slot \"est_errors\": ## numeric(0) Our constructor has successfully created our object of class monteCarloIntegration. As soon as we create the object, we want R to compute estimates (we store the cumulative mean) of the integral. We do this with the intialize method. We also compute errors which are explained and used below.\nsetMethod(\"initialize\", \"monteCarloIntegration\", function(.Object, func, lower_lim, upper_lim) { .Object@func \u003c- func .Object@lower_lim \u003c- lower_lim .Object@upper_lim \u003c- upper_lim temp \u003c- func(runif(1e4, lower_lim, upper_lim)) estimates \u003c- cumsum(temp)/1:1e4 .Object@estimates \u003c- as.numeric(estimates) est_errors \u003c- sqrt(cumsum((temp - estimates)^2))/1:1e4 .Object@est_errors \u003c- as.numeric(est_errors) return(.Object) }) We now construct the object again and perform a sanity check by using the built in R function integrate().\nintegral_mc \u003c- monte_carlo_int(h, 0, 1) integral_mc@estimates[1e4] ## [1] 0.3644594 integrate(h, 0, 1) ## 0.4128169 with absolute error \u003c 4.8e-09 We see that our estimates are very close. As stated above, the @ operator should not be used outside of methods. It is only used here as we have not yet created getter and setter methods.\nWe now want to implement a plotting method which will allow us to see if the estimate has converged. We also implement a confidence bound using the asymptotic variance of the approximation \\[var(\\bar{h}_n) = \\frac{1}{n} \\int_{\\mathcal{X}} (h(X) - \\mathbb{E}_f[h(X)])f(x)dx\\] which can be estimated using the sample \\((X_1, \\dots, X_n)\\), by \\[v_n = \\frac{1}{n^2} \\sum_{j=1}^n [h(x_j) - \\bar{h}_n]^2.\\] Using the Central Limit Theorem, for large \\(n\\) we have that \\[\\frac{\\bar{h}_n - \\mathbb{E}_f[h(X)])f(x)}{\\sqrt{(v_n)}}\\] is approximately a standard normal random variable. This then allows us to write down confidence bounds.\nsetMethod(\"plot\", \"monteCarloIntegration\", function(x, ...) { seq_temp \u003c- seq(x@lower_lim, x@upper_lim, length.out = 1000) seq_func \u003c- x@func(seq_temp) r_est \u003c- integrate(x@func, x@lower_lim, x@upper_lim)$value cb_lower \u003c- x@estimates - 2*x@est_errors cb_upper \u003c- x@estimates + 2*x@est_errors par(mfrow=c(1,2)) plot(seq_temp, seq_func, type = 'l', main = \"A plot of h(x) over the interval [0,1]\", xlab = expression(x), ylab = expression(h(x))) plot(x@estimates, type = 'l', ylim = c(0.8*min(cb_lower), 1.2*max(cb_upper)), main = \"An approximation of the integral of h(x)\", ylab=\"\", xlab=\"\") polygon(c(1:1e4, 1e4:1), c(cb_lower, rev(cb_upper)), col = adjustcolor(\"skyblue\", alpha.f=0.1), border = NA) lines(cb_lower, col = \"blue\") lines(cb_upper, col = \"blue\") abline(h = r_est, lty = 2, col = 'red') }) plot(integral_mc) ","wordCount":"2282","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Jake Spiteri"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jakespiteri.co.uk/portfolio/computing-1/report-5/"},"publisher":{"@type":"Organization","name":"Jake Spiteri","logo":{"@type":"ImageObject","url":"https://jakespiteri.co.uk/favi.png"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://jakespiteri.co.uk/ accesskey=h title="Home (Alt + H)"><div class=custom-logo><span class=logo__mark></span>
<span class=logo__text>>$ cd /home</span>
<span class=logo__cursor style=background-color:#1290ff></span></div></a><div class=logo-switches></div></div><ul id=menu style=font-family:monospace,monospace><li><a href=https://jakespiteri.co.uk/about/ title=/about><span>/about</span></a></li><li><a href=https://jakespiteri.co.uk/portfolio/ title=/portfolio><span>/portfolio</span></a></li><li><a href=https://jakespiteri.co.uk/blog/ title=/blog><span>/blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jakespiteri.co.uk/>Home</a>&nbsp;»&nbsp;<a href=https://jakespiteri.co.uk/portfolio/>Portfolio</a>&nbsp;»&nbsp;<a href=https://jakespiteri.co.uk/portfolio/computing-1/>Statistical Computing 1</a></div><h1 class=post-title>Portfolio Report 5: Functional and object-oriented programming</h1><div class=post-meta>Jake Spiteri&nbsp;|&nbsp;<a href=https://github.com/jakespiteri/jakespiteri.github.io/tree/master/portfolio/computing-1/report-5/index.html rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><div id=programming-paradigms class="section level1"><h1>Programming paradigms</h1><p>R supports multiple programming paradigms. Programming paradigms describe the way in which code is written and structured for larger projects. The types of programming structures are:</p><ul><li>Imperative programming — We define a sequence of instructions that modify the ‘state’ of the program.<ul><li>Object-oriented programming — Objects combine the machine’s state with a set of methods. Programs are then defined via the construction of objects.</li></ul></li><li>Declarative programming — A sequence of operations is defined that only specify what the output of the program should be. The exact details of how the program is implemented is determined by the programming language.</li><li>Functional programming — Functions are defined to act identically to mathematical functions. A program is then a sequence of function applications.</li></ul><p>In this document we will explore the use and applications of functional and object-oriented programming.</p></div><div id=functional-programming class="section level1"><h1>Functional programming</h1><div id=first-class-functions class="section level2"><h2>First-class functions</h2><p>R has first-class functions. These are functions that behave like any other data structure. A language has first-class functions if:</p><ul><li>Functions can be used as arguments to other functions,</li><li>Functions can be returned by functions,</li><li>Functions can be stored in data structures.</li></ul><p>In functional programming we may want to provide a function as an input to another function. We have seen this feature in the <code>Map</code> and <code>Reduce</code> functions in R.</p><pre class=r><code>square &lt;- function(x) x*x
unlist(Map(square, 1:5))</code></pre><pre><code>## [1]  1  4  9 16 25</code></pre><pre class=r><code>Reduce(&#39;+&#39;, 1:5)</code></pre><pre><code>## [1] 15</code></pre><pre class=r><code>Reduce(&#39;+&#39;, unlist(Map(square, 1:5)))</code></pre><pre><code>## [1] 55</code></pre><pre class=r><code># we can also use multiple functions within one function
Reduce(function(x,y) x*y, unlist(Map(square, 1:5)))</code></pre><pre><code>## [1] 14400</code></pre><p>We can also take a function as an input, manipulate it, and return it as an output.</p></div><div id=object-oriented-programming class="section level2"><h2>Object-oriented programming</h2><div id=introduction class="section level3"><h3>Introduction</h3><p>The main reason to use object-oriented programming (OOP) is <strong>polymorphism</strong>. This provides our functions with reusability and extendability. Polymorphism allows a single object to have multiple methods for various types of input.</p><p>In OOP, functionality is <strong>encapsulated</strong> within an <strong>object</strong>. Every object has a type, which is the class that it belongs to. An implementation for a specific class is called a method. The class defines the fields, which contain the data possessed by every instance of that class. The current state of an object is thus specified by its fields, and its behavior is specified by its methods. If one class is derived from the other, the child class may inherit the fields and methods of the parent class.</p><p>R implements three different object-oriented systems:</p><ul><li>S3 — An informal implementation of OOP which relies upon common conventions.</li><li>S4 — A formal rewrite of S3.</li><li>Reference classes (RC) — Implements encapsulated OOP. In this implementation objects are <strong>mutable</strong>. That is, objects are modified in place.</li></ul><p>In this report we will look at the S3 and S4 systems.</p></div><div id=s3 class="section level3"><h3>S3</h3><p>S3 is the simplest and most informal system for OOP in R. S3 does not use formal class definitions. It offers an extremely flexible system, which may allow you to do certain things which are not recommended. Since S3 has few built-in constraints, we will outline best practices here.</p><p>An S3 object is an object of a base type with the attribute <code>class</code> set to the class name. It will be good practice to have a constructor function which can be called to initialize all relevant elements of the object, and then return the object. We may also require a validator which checks our arguments within a separate function. A helper function is also useful for end users that makes the constructor more user-friendly.</p><p>Below we will implement linear regression as an S3 object.</p><pre class=r><code># we set the seed for reproducibility
set.seed(1)

# create a dataset
n &lt;- 100
w &lt;- matrix(c(2, -1), ncol=1)
X &lt;- rbind(rnorm(100,0,1), rep(1,n))
y &lt;- t(w)%*%X + rnorm(100, 0, 1)
plot(X[1,], y[1,])</code></pre><p><img src=https://jakespiteri.co.uk/portfolio/computing-1/report-5/index_files/figure-html/unnamed-chunk-3-1.png width=672></p><pre class=r><code># we now define a constructor which will return an object of a specified class
# the constructor does some operations
# encapsulates data in the object
# assigns a class to the object
# returns the object
simple_lin_regression &lt;- function(X, y) {
  
  # compute the OLS parameter estimates
  w_hat &lt;- solve(X%*%t(X))%*%X%*%t(y)
  
  # the object encapsulates (X, y, and w_hat)
  slr &lt;- list(response = as.numeric(y), regressor = X, param_estimate = w_hat)
  
  # we declare the object &#39;slr&#39; to be an S3 object of class &quot;simple_lin_regression&quot;
  class(slr) &lt;- &quot;simple_lin_regression&quot;
  
  return(slr)
}

slr &lt;- simple_lin_regression(X, y)</code></pre><p>Given the above class simple_lin_regression, we will define some methods for the class. To define a method in S3, a generic function of the same name needs to already exist. If it doesn’t already exist we can easily declare a new generic function.</p><p>We define a new method as a function with function name <code>[method_name].[class_name]</code>.</p><p>We implement a <code>print</code> method which prints relevant information about the object such as the estimated coefficients, and we implement a <code>plot</code> method. Note that <code>print</code> and <code>plot</code> are already generic methods in <code>R</code> and so we do not need to define them as such here.</p><pre class=r><code>print.simple_lin_regression &lt;- function(x, ...) {
  cat(&quot;head(x) =&quot;, head(x$regressor[1,]), &quot;\n&quot;)
  cat(&quot;head(y) =&quot;, head(x$response), &quot;\n&quot;)
  cat(&quot;Estimated regression: E[y|x] = b0 + b1*x\n&quot;)
  cat(&quot;b0 = &quot;, x$param_estimate[1,1], &quot;, b1 = &quot;, x$param_estimate[2,1], &quot;.\n&quot;, sep=&quot;&quot;)
}

plot.simple_lin_regression &lt;- function(x, ...) {
  plot(x$regressor[1,], slr$response,
       xlab=expression(X), ylab=expression(Y)
  )
  abline(a = x$param_estimate[2], b = x$param_estimate[1], col = &quot;red&quot;)
}</code></pre><p>Let’s use the methods we defined above. The correct syntax is <code>[method_name](object])</code>.</p><pre class=r><code>print(slr)</code></pre><pre><code>## head(x) = -0.6264538 0.1836433 -0.8356286 1.595281 0.3295078 -0.8204684 
## head(y) = -2.873274 -0.5905975 -3.582179 2.34859 -0.9955691 -0.8736495 
## Estimated regression: E[y|x] = b0 + b1*x
## b0 = 1.99894, b1 = -1.037693.</code></pre><pre class=r><code>plot(slr)</code></pre><p><img src=https://jakespiteri.co.uk/portfolio/computing-1/report-5/index_files/figure-html/unnamed-chunk-5-1.png width=672></p><p>We want to define a method called <code>residual_analysis</code>. In order to do this we must define a generic method with the same name.</p><pre class=r><code># define the generic method
residual_analysis &lt;- function(x){
  UseMethod(&quot;residual_analysis&quot;)
}

# implement the method for class
residual_analysis.simple_lin_regression &lt;- function(x) {
  predictions &lt;- t(x$param_estimate) %*% X
  plot(predictions, x$response - predictions,
       main = &quot;Residual analysis&quot;,
       xlab = expression(hat(Y)), ylab = expression(Y-hat(Y)))
}

residual_analysis(slr)</code></pre><p><img src=https://jakespiteri.co.uk/portfolio/computing-1/report-5/index_files/figure-html/unnamed-chunk-6-1.png width=672></p><p>In S3, classes can inherit methods from their parent classes. This is demonstrated below. Note that we can create classes on the fly — we not need to formally define them. We simply define an object and then assign its class.</p><pre class=r><code>P &lt;- structure(numeric(), class = &quot;parent_class&quot;)
C &lt;- structure(numeric(), class = c(&quot;child_class&quot;, &quot;parent_class&quot;))

print.parent_class &lt;- function(x) {
  cat(&quot;This method belongs to the parent class&quot;)
}</code></pre><p>We check that the method works for both P and C.</p><pre class=r><code>print(P)</code></pre><pre><code>## This method belongs to the parent class</code></pre><pre class=r><code>print(C)</code></pre><pre><code>## This method belongs to the parent class</code></pre><p>We now provide the <code>child_class</code> class with its own print method.</p><pre class=r><code>print.child_class &lt;- function(x) {
  cat(&quot;This method belongs to the child class&quot;)
}

print(C)</code></pre><pre><code>## This method belongs to the child class</code></pre><pre class=r><code>print(P)</code></pre><pre><code>## This method belongs to the parent class</code></pre><pre class=r><code>print(C)</code></pre><pre><code>## This method belongs to the child class</code></pre></div><div id=s4 class="section level3"><h3>S4</h3><p>S4 implements a more formal approach to OOP. Unlike S3, all OOP relevant elements must be defined explicitly. S4 provides specialized functions for defining elements such as <code>setClass()</code>, <code>setGeneric()</code>, and <code>setMethod()</code>. While this requires more effort, it provides more clarity and allows us to use built-in integrity checks.</p><p>We repeat the linear regression task.</p><pre class=r><code>library(methods)</code></pre><p>We must first create the <code>simple_lin_regression</code> class. We must give it the name of the class being defined, and the slots which represent the fields’ names and types. Slots can be accessed using the specialized subsetting operator <code>@</code>, however we should avoid using this outside of methods in order to provide encapsulation. In order to obtain or change an object’s components we should use getter and setter methods which we define.</p><pre class=r><code>setClass(&quot;simple_lin_regression&quot;,
         slots = c(
           response = &quot;numeric&quot;,
           regressor = &quot;numeric&quot;,
           estimate = &quot;numeric&quot;
         )
)</code></pre><p>We can instantiate a new object in the class using <code>new()</code>. We create a constructor so that the end user does not have to use the <code>new</code> function.</p><pre class=r><code>simple_lin_regression &lt;- function(X,y) {
  slr &lt;- new(&quot;simple_lin_regression&quot;,
             response = y,
             regressor = X)
  return(slr)
}</code></pre><p>We quickly test that our constructor function works for our generated data.</p><pre class=r><code>slr &lt;- simple_lin_regression(X[1,1:5],y[1,1:5])
slr</code></pre><pre><code>## An object of class &quot;simple_lin_regression&quot;
## Slot &quot;response&quot;:
## [1] -2.8732743 -0.5905975 -3.5821789  2.3485904 -0.9955691
## 
## Slot &quot;regressor&quot;:
## [1] -0.6264538  0.1836433 -0.8356286  1.5952808  0.3295078
## 
## Slot &quot;estimate&quot;:
## numeric(0)</code></pre><p>Note that the slot for estimate exists but we have not given it a value yet. It is currently <code>numeric(0)</code>. We will create an initialization method that will compute the estimate when we create an object.</p><pre class=r><code>setMethod(&quot;initialize&quot;, &quot;simple_lin_regression&quot;,
          function(.Object, response, regressor) {
            .Object@response &lt;- response
            .Object@regressor &lt;-  regressor
            
            n &lt;- length(response)
            X &lt;- rbind(regressor, rep(1,n))
            w_hat &lt;- solve(X%*%t(X))%*%X %*% response
            .Object@estimate &lt;- as.numeric(w_hat)
            return(.Object)
          })</code></pre><p>When we use the function <code>new()</code> we see that it calls a non-standard generic function <code>initialize()</code>. We can define a custom initialize method that assigns values (such as default values) to an object’s components. We can also perform a computation like above and set its output to one of the object’s components. The first two arguments in the above specify the method <code>initialize</code>, and the class for which it is defined for <code>simple_lin_regression</code>. It returns the object <code>.Object</code> with the components it has been assigned.</p><p>Similar to what we did for S3, we implement print and pot functions for S4. Recall that in order to access the components of our object we must use the <code>@</code> operator.</p><pre class=r><code>setMethod(&quot;print&quot;, &quot;simple_lin_regression&quot;,
  function(x, ...) {
    cat(&quot;head(x) =&quot;, head(x@regressor), &quot;\n&quot;)
    cat(&quot;head(y) =&quot;, head(x@response), &quot;\n\n&quot;)
    cat(&quot;Estimated regression: E[y|x] = b0 + b1 * x\n&quot;)
    cat(&quot;b0 = &quot;, x@estimate[1], &quot; and b1 = &quot;, x@estimate[2], &quot;.\n&quot;, sep = &quot;&quot;)
  }
)

setMethod(&quot;plot&quot;, &quot;simple_lin_regression&quot;,
  function(x, y = NULL, ...) {
    plot(x = x@regressor, y = x@response,
         xlab = expression(X), ylab = expression(Y))
    abline(a = x@estimate[2], b = x@estimate[1], col = &quot;red&quot;)
  }
)</code></pre><pre class=r><code>slr &lt;- simple_lin_regression(X[1,], y[1,])
print(slr)</code></pre><pre><code>## head(x) = -0.6264538 0.1836433 -0.8356286 1.595281 0.3295078 -0.8204684 
## head(y) = -2.873274 -0.5905975 -3.582179 2.34859 -0.9955691 -0.8736495 
## 
## Estimated regression: E[y|x] = b0 + b1 * x
## b0 = 1.99894 and b1 = -1.037693.</code></pre><pre class=r><code>plot(slr)</code></pre><p><img src=https://jakespiteri.co.uk/portfolio/computing-1/report-5/index_files/figure-html/unnamed-chunk-16-1.png width=672></p><p>Once again, we implement a method called <code>residual_analysis</code> which is a not a generic method and must be defined using <code>setGeneric()</code>.</p><pre class=r><code>setGeneric(&quot;residual_analysis&quot;)</code></pre><pre><code>## [1] &quot;residual_analysis&quot;</code></pre><pre class=r><code>setMethod(&quot;residual_analysis&quot;, &quot;simple_lin_regression&quot;,
          function(x) {
            predictions &lt;- x@estimate[2] + x@estimate[1] * x@regressor
            plot(x = predictions, y = x@response - predictions,
                 xlab = expression(hat(Y)),
                 ylab = expression(Y - hat(Y)))
          })

residual_analysis(slr)</code></pre><p><img src=https://jakespiteri.co.uk/portfolio/computing-1/report-5/index_files/figure-html/unnamed-chunk-18-1.png width=672></p></div></div><div id=monte-carlo-example-of-s4 class="section level2"><h2>Monte carlo example of S4</h2><p>We will implement Monte Carlo integration using S4.</p><p>We start with the general problem: We want to compute an integral
<span class="math display">\[ \mathbb{E}_f[h(X)] = \int_\mathcal{X} h(x) f(x) dx \]</span>
where <span class="math inline">\(\mathcal{X}\)</span> is the set from which the random variable <span class="math inline">\(X\)</span> takes its values. In order to compute this integral numerically, we are going to generate a sample <span class="math inline">\((X_1, \dots, X_n)\)</span> from the density <span class="math inline">\(f\)</span> and approximate the integral via the empirical mean
<span class="math display">\[ \bar{h}_n := \frac{1}{n} \sum_{i=1}^n h(x_i).\]</span>
This is a logical estimator as <span class="math inline">\(\bar{h}_n \rightarrow \mathbb{E}_f[h(X)]\)</span> as <span class="math inline">\(n \rightarrow \infty\)</span> almost surely (by the Strong Law of Large Numbers).</p><p>We implement the above method in a class called <code>monteCarloIntegration</code>.</p><pre class=r><code>setClass(&quot;monteCarloIntegration&quot;,
         slots = c(
           func = &quot;function&quot;,
           lower_lim = &quot;numeric&quot;,
           upper_lim = &quot;numeric&quot;,
           estimates = &quot;numeric&quot;,
           est_errors = &quot;numeric&quot;
         ))</code></pre><p>We now create a constructor function.</p><pre class=r><code>monte_carlo_int &lt;- function(func, lower, upper) {
  monte_carlo_integral &lt;- new(&quot;monteCarloIntegration&quot;,
                              func = func, 
                              lower_lim = lower, 
                              upper_lim = upper)
  return(monte_carlo_integral)
}</code></pre><p>Let’s test that our constructor works. We are going to integrate the function
<span class="math display">\[h(x) := [\cos(10x) + sin(4x)]^3\]</span>
over [0,1].</p><pre class=r><code>h &lt;- function(x) {(cos(10*x) + sin(4*x))^3}
integral &lt;- monte_carlo_int(h, 0, 1)
integral</code></pre><pre><code>## An object of class &quot;monteCarloIntegration&quot;
## Slot &quot;func&quot;:
## function(x) {(cos(10*x) + sin(4*x))^3}
## 
## Slot &quot;lower_lim&quot;:
## [1] 0
## 
## Slot &quot;upper_lim&quot;:
## [1] 1
## 
## Slot &quot;estimates&quot;:
## numeric(0)
## 
## Slot &quot;est_errors&quot;:
## numeric(0)</code></pre><p>Our constructor has successfully created our object of class <code>monteCarloIntegration</code>. As soon as we create the object, we want R to compute estimates (we store the cumulative mean) of the integral. We do this with the <code>intialize</code> method. We also compute errors which are explained and used below.</p><pre class=r><code>setMethod(&quot;initialize&quot;, &quot;monteCarloIntegration&quot;,
          function(.Object, func, lower_lim, upper_lim) {
            .Object@func &lt;- func
            .Object@lower_lim &lt;- lower_lim
            .Object@upper_lim &lt;- upper_lim
            
            temp &lt;- func(runif(1e4, lower_lim, upper_lim))
            estimates &lt;- cumsum(temp)/1:1e4
            .Object@estimates &lt;- as.numeric(estimates)
            
            est_errors &lt;- sqrt(cumsum((temp - estimates)^2))/1:1e4
            .Object@est_errors &lt;- as.numeric(est_errors)
            
            return(.Object)
          })</code></pre><p>We now construct the object again and perform a sanity check by using the built in R function <code>integrate()</code>.</p><pre class=r><code>integral_mc &lt;- monte_carlo_int(h, 0, 1)

integral_mc@estimates[1e4]</code></pre><pre><code>## [1] 0.3644594</code></pre><pre class=r><code>integrate(h, 0, 1)</code></pre><pre><code>## 0.4128169 with absolute error &lt; 4.8e-09</code></pre><p>We see that our estimates are very close. As stated above, the <code>@</code> operator should not be used outside of methods. It is only used here as we have not yet created getter and setter methods.</p><p>We now want to implement a plotting method which will allow us to see if the estimate has converged. We also implement a confidence bound using the asymptotic variance of the approximation
<span class="math display">\[var(\bar{h}_n) = \frac{1}{n} \int_{\mathcal{X}} (h(X) - \mathbb{E}_f[h(X)])f(x)dx\]</span>
which can be estimated using the sample <span class="math inline">\((X_1, \dots, X_n)\)</span>, by
<span class="math display">\[v_n = \frac{1}{n^2} \sum_{j=1}^n [h(x_j) - \bar{h}_n]^2.\]</span>
Using the Central Limit Theorem, for large <span class="math inline">\(n\)</span> we have that
<span class="math display">\[\frac{\bar{h}_n - \mathbb{E}_f[h(X)])f(x)}{\sqrt{(v_n)}}\]</span>
is approximately a standard normal random variable. This then allows us to write down confidence bounds.</p><pre class=r><code>setMethod(&quot;plot&quot;, &quot;monteCarloIntegration&quot;,
          function(x, ...) {
            seq_temp &lt;- seq(x@lower_lim, x@upper_lim, length.out = 1000)
            seq_func &lt;- x@func(seq_temp)
            
            r_est &lt;- integrate(x@func, x@lower_lim, x@upper_lim)$value
            cb_lower &lt;- x@estimates - 2*x@est_errors
            cb_upper &lt;- x@estimates + 2*x@est_errors
            
            par(mfrow=c(1,2))
            plot(seq_temp, seq_func, type = &#39;l&#39;,
                 main = &quot;A plot of h(x) over the interval [0,1]&quot;,
                 xlab = expression(x), ylab = expression(h(x)))
            plot(x@estimates, type = &#39;l&#39;, 
                 ylim = c(0.8*min(cb_lower), 1.2*max(cb_upper)),
                 main = &quot;An approximation of the integral of h(x)&quot;,
                 ylab=&quot;&quot;, xlab=&quot;&quot;)
            polygon(c(1:1e4, 1e4:1), c(cb_lower, rev(cb_upper)),
                    col = adjustcolor(&quot;skyblue&quot;, alpha.f=0.1), border = NA)
            lines(cb_lower, col = &quot;blue&quot;)
            lines(cb_upper, col = &quot;blue&quot;)
            abline(h = r_est, lty = 2, col = &#39;red&#39;)
          })</code></pre><pre class=r><code>plot(integral_mc)</code></pre><p><img src=https://jakespiteri.co.uk/portfolio/computing-1/report-5/index_files/figure-html/unnamed-chunk-25-1.png width=960></p></div></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://jakespiteri.co.uk/portfolio/computing-1/report-4/><span class=title>« Prev</span><br><span>Portfolio Report 4: Vectorization and parallel computing</span></a>
<a class=next href=https://jakespiteri.co.uk/portfolio/computing-1/report-6/><span class=title>Next »</span><br><span>Portfolio Report 6: Tidyverse</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://jakespiteri.co.uk/>Jake Spiteri</a></span>
<span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>