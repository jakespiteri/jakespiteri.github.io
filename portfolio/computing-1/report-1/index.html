<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Portfolio Report 1: An Introduction to R | Jake Spiteri</title><meta name=keywords content><meta name=description content="R is a high-level programming language widely used for statistical computing. Base R provides users with a large variety of statistical and graphical tools, which are easily extended via the use of packages.
R is an interpreted programming language. This means that R users execute code via a command-line interpreter and code is interpreted into low-level instructions one line at a time. Integrated development environments (IDEs) such as RStudio provide easy access to such an interpreter through the use of a console."><meta name=author content="Jake Spiteri"><link rel=canonical href=https://jakespiteri.co.uk/portfolio/computing-1/report-1/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jakespiteri.co.uk/favi.png><link rel=icon type=image/png sizes=16x16 href=https://jakespiteri.co.uk/favi.png><link rel=icon type=image/png sizes=32x32 href=https://jakespiteri.co.uk/favi.png><link rel=apple-touch-icon href=https://jakespiteri.co.uk/favi.png><link rel=mask-icon href=https://jakespiteri.co.uk/favi.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Portfolio Report 1: An Introduction to R"><meta property="og:description" content="R is a high-level programming language widely used for statistical computing. Base R provides users with a large variety of statistical and graphical tools, which are easily extended via the use of packages.
R is an interpreted programming language. This means that R users execute code via a command-line interpreter and code is interpreted into low-level instructions one line at a time. Integrated development environments (IDEs) such as RStudio provide easy access to such an interpreter through the use of a console."><meta property="og:type" content="article"><meta property="og:url" content="https://jakespiteri.co.uk/portfolio/computing-1/report-1/"><meta property="og:image" content="https://jakespiteri.co.uk/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="portfolio"><meta property="og:site_name" content="Jake Spiteri"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jakespiteri.co.uk/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Portfolio Report 1: An Introduction to R"><meta name=twitter:description content="R is a high-level programming language widely used for statistical computing. Base R provides users with a large variety of statistical and graphical tools, which are easily extended via the use of packages.
R is an interpreted programming language. This means that R users execute code via a command-line interpreter and code is interpreted into low-level instructions one line at a time. Integrated development environments (IDEs) such as RStudio provide easy access to such an interpreter through the use of a console."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Portfolio","item":"https://jakespiteri.co.uk/portfolio/"},{"@type":"ListItem","position":2,"name":"Statistical Computing 1","item":"https://jakespiteri.co.uk/portfolio/computing-1/"},{"@type":"ListItem","position":3,"name":"Portfolio Report 1: An Introduction to R","item":"https://jakespiteri.co.uk/portfolio/computing-1/report-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Portfolio Report 1: An Introduction to R","name":"Portfolio Report 1: An Introduction to R","description":"R is a high-level programming language widely used for statistical computing. Base R provides users with a large variety of statistical and graphical tools, which are easily extended via the use of packages.\nR is an interpreted programming language. This means that R users execute code via a command-line interpreter and code is interpreted into low-level instructions one line at a time. Integrated development environments (IDEs) such as RStudio provide easy access to such an interpreter through the use of a console.","keywords":[],"articleBody":" R is a high-level programming language widely used for statistical computing. Base R provides users with a large variety of statistical and graphical tools, which are easily extended via the use of packages.\nR is an interpreted programming language. This means that R users execute code via a command-line interpreter and code is interpreted into low-level instructions one line at a time. Integrated development environments (IDEs) such as RStudio provide easy access to such an interpreter through the use of a console. Interpreted languages are looked at in more depth in a later report, but it is important to note that interpreted languages such a R are slow in comparison to compiled languages. Due to this, a majority of the base R code is written in low-level compiled languages — approximately 50% of the base R code is written in C/C++, 30% in Fortran, and 20% in R.\nHow to run R code There are many ways that we can work with R. We can work directly from a terminal, in which we can interactively input commands which are then interpreted as R code, or we can directly run an R script in the terminal (a text file with extension ‘.R’). Once R is installed one can initialize a session in the terminal by simply typing R, and we can run an R script with the command Rscript path/to/Rscript. Running lines of code in the terminal is useful for quickly testing ideas, but a script is preferred for analyses which require more thought as a script provides access to and stores all code that has been run.\nWe can improve our workflow by using an IDE such as RStudio. RStudio greatly improves upon the R coding experience in a number of ways:\nPanes — RStudio’s default interface consists of four ‘panes’ which provide access to a script window, console window, environment window, and a files/plots/help window. These panes are also highly customizable. Panes allow us to efficiently switch between writing a script, running code in the console, and viewing plots or function documentation.\nText Editor — RStudio’s text editor provides many of the features you would expect from an IDE, such as syntax highlighting, code completion, and find and replace with regular expressions.\nAutocompletion — A particularly useful key in RStudio is the Tab key. When typing a function or object name, pressing the Tab key will autocomplete the name; once a function has been specified e.g. lm(), pressing the Tab key once more will list all of the possible arguments for the given function.\nFundamentals We now look at some fundamentals of R programming. This will only be a brief introduction but should cover a wide-array of topics.\nVariable names and types In R a value can be assigned to a variable using the assignment operator \u003c-. It is possible to use = to assign a value to a variable, but it is not recommended. If the specified variable already exists, this will overwrite the existing variable. For example,\nx \u003c- 1 x ## [1] 1 x \u003c- 2 x ## [1] 2 As seen above, simply assigning a variable does not produce an output. We can call the variable to implicitly print the variable’s value.\nVariables in R can take on many different data types. These data types can be seen in Table 1 below.\nAs seen in the table we can also assign strings and logical values to variables.\nx \u003c- \"hello world\" x ## [1] \"hello world\" x \u003c- TRUE x ## [1] TRUE A variable name can consist of letters, numbers, dots, and underscores.\nArithmetic As you would expect, R is capable of performing many operations. Some are shown below.\n# addition 1 + 1 ## [1] 2 # subtraction 3 - 1 ## [1] 2 # multiplication 1 * 2 ## [1] 2 # division 6 / 3 ## [1] 2 # exponentiation 2^2 ## [1] 4 # integer division 5 %/% 2 ## [1] 2 # integer modulus 7 %% 5 ## [1] 2 Of course, R implements the order of operations which we all know. We can change this behavior by using parentheses.\n2 + 4 / 2 ## [1] 4 (2 + 4) / 2 ## [1] 3 Conditional Statements R can execute certain commands conditional upon a logical value by using if/else statements. These statements are commonly of the form\nif () { } else { } We can also nest if statements to obtain more complicated logic. A simple example is shown below.\nx \u003c- TRUE if (x) { print(\"x is TRUE\") } else { print(\"x is FALSE\") } ## [1] \"x is TRUE\" x \u003c- FALSE if (x) { print(\"x is TRUE\") } else { print(\"x is FALSE\") } ## [1] \"x is FALSE\" The curly brackets are not always necessary but are always recommended in order to avoid bugs. For example\n# setup x \u003c- 4 # brackets are not needed if (x\u003c5) print(\"x is less than 5\") ## [1] \"x is less than 5\" # brackets are needed if (x\u003e5) print(\"nice\") print(\"x is more than five\") ## [1] \"x is more than five\" The logical value for the last if loop is FALSE, so we would expect nothing to be printed. The error occurs because the last if statement is equivalent to\nif (x\u003e5) { print(\"nice\") } print(\"x is more than five\") ## [1] \"x is more than five\" Whereas what we actually wanted was\nif (x\u003e5) { print(\"nice\") print(\"x is more than five\") } Relational and logical operators We often want to generate a TRUE or FALSE value dependent on some variables, like the x \u003c 5 seen above. The relational operators are We may want to combine logical values using logical operators. The logical operators can be found in Table 3 below. Functions We can easily create functions in R. Functions allow us to simplify our code by putting repeated computations into a function. The syntax used to create a function is\n\u003c- function() { } For example, suppose we wanted to easily find the \\(p\\)-norm of a vector.\nlp_norm \u003c- function(x, p) { norm \u003c- sum(abs(x)^p)^(1/p) return(norm) } # l1 norm lp_norm(c(-1,1), p=1) # should be 2 ## [1] 2 # l2 norm lp_norm(c(3,4), p=2) # should be 5 ## [1] 5 It is good practice to return the final argument you want to output.\nData structures: vectors, matrices, and lists There are many data structures that we frequently use in R. Below is a table categorizing some of the most common. Some structures are homogeneous in that every element within them has the same data type, and some are heterogeneous in that their elements can be of different types. Below we generate some of the above data structures.\n## vectors # generate sequence from 1 to 10 x \u003c- 1:10 print(x) ## [1] 1 2 3 4 5 6 7 8 9 10 # get the length of x length(x) ## [1] 10 # get the data type of x typeof(x) ## [1] \"integer\" # generate new x of type x \u003c- c(\"a\", \"b\", \"c\") print(x) ## [1] \"a\" \"b\" \"c\" # get the data type of x typeof(x) ## [1] \"character\" # index into x x[1] ## [1] \"a\" # reassign an index x[2] \u003c- \"d\" print(x) ## [1] \"a\" \"d\" \"c\" # we cannot change the data type # below we try to input a numeric 1, but R inputs a STRING \"1\" x[2] \u003c- as.numeric(1) print(x) ## [1] \"a\" \"1\" \"c\" typeof(x[2]) ## [1] \"character\" ## matrices # generate a matrix x \u003c- matrix(c(1, 0, 0, 1), 2, 2) x ## [,1] [,2] ## [1,] 1 0 ## [2,] 0 1 # check dimensions dim(x) ## [1] 2 2 # get first row of x x[1, ] ## [1] 1 0 # assign colnames colnames(x) \u003c- c(\"column 1\", \"column 2\") x ## column 1 column 2 ## [1,] 1 0 ## [2,] 0 1 # check type of elements typeof(x) ## [1] \"double\" # many R functions can be applied elementwise sin(x) ## column 1 column 2 ## [1,] 0.841471 0.000000 ## [2,] 0.000000 0.841471 max(x) ## [1] 1 # try to input a string as the top left entry x[1,1] \u003c- \"test\" x ## column 1 column 2 ## [1,] \"test\" \"0\" ## [2,] \"0\" \"1\" # we have successfully replaced the [1,1] element but the data type # of every entry has changed typeof(x) ## [1] \"character\" # what happens if we try to find the maximum value now max(x) ## [1] \"test\" ## lists # generate a list x \u003c- list(numbers = c(1, 2, 3), letters = c(\"a\", \"b\", \"c\")) x ## $numbers ## [1] 1 2 3 ## ## $letters ## [1] \"a\" \"b\" \"c\" # index into a list using $ x$numbers ## [1] 1 2 3 # index into a list using [[ ]] x[[1]] ## [1] 1 2 3 # index into a vector in a list x[[1]][1] ## [1] 1 # create new entries in a list on the fly x$letters_backwards \u003c- rev(x$letters) x ## $numbers ## [1] 1 2 3 ## ## $letters ## [1] \"a\" \"b\" \"c\" ## ## $letters_backwards ## [1] \"c\" \"b\" \"a\" # reformat a name in a list names(x)[3] \u003c- \"letters backwards\" x ## $numbers ## [1] 1 2 3 ## ## $letters ## [1] \"a\" \"b\" \"c\" ## ## $`letters backwards` ## [1] \"c\" \"b\" \"a\" # check the type of x typeof(x) ## [1] \"list\" # check the type of a named vector in x typeof(x$numbers) ## [1] \"double\" # lists can even contain functions x \u003c- list() x$eval \u003c- function(x, y) { return(x*y) } # use function x$eval(2, 2) ## [1] 4 Lexical scoping R uses lexical scoping, which determines how a free variable within a function obtains a value. Consider the following function:\nm \u003c- function(x) { return(x * y) } This function has only one argument x. The function also requires another variable y which has not been defined locally in the function and is not given as a formal argument — this is called a free variable. The scoping rules implemented by a language determine how such a free variable obtains its value.\nLexical scoping means that the values of free variables are searched for in the environment in which the function was defined. If they are not found here, then R searches for their value in the parent environment. After reaching the top-level environment, R will look down the search list (found using search()). If R arrives at the empty environment without finding values for free variables, we will get an error.\nLet’s implement the lp-norm again and demonstrate lexical scoping.\n# create a constructor function make_lp_norm \u003c- function(p) { norm \u003c- function(x) { return(sum(abs(x)^p)^(1/p)) } return(norm) } # use constructor to make l1 norm function l1_norm \u003c- make_lp_norm(1) l1_norm(c(1,1)) # should be 2 ## [1] 2 Let’s look at the code for l1_norm.\nl1_norm ## function(x) { ## return(sum(abs(x)^p)^(1/p)) ## } ## We see that it depends on a free variable p. Recall that the value of the free variable is obtained from the environment in which the function was defined. In this case, p is equal to 1. Let’s check this by exploring the environment of the l1_norm.\n# list objects in l1_norm's environment ls(environment(l1_norm)) ## [1] \"norm\" \"p\" get(\"p\", environment(l1_norm)) ## [1] 1 A simpler example would be to define a variable in the global environment, and then use it in a function.\nn \u003c- 2 square \u003c- function(x) { return(x^n) } # test the square function square(2) ## [1] 4 square(3) ## [1] 9 A problem occurs when we expect a variable to be defined within a function, but it is defined in the global environment. Continuing with the above example, it seems plausible that we may reassign the value of n at some point in our analyses.\n# reassign n n \u003c- 3 # the square function no longer works as expected square(2) ## [1] 8 ","wordCount":"2020","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Jake Spiteri"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jakespiteri.co.uk/portfolio/computing-1/report-1/"},"publisher":{"@type":"Organization","name":"Jake Spiteri","logo":{"@type":"ImageObject","url":"https://jakespiteri.co.uk/favi.png"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://jakespiteri.co.uk/ accesskey=h title="Home (Alt + H)"><img src=https://jakespiteri.co.uk/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://jakespiteri.co.uk/about/ title=/about><span>/about</span></a></li><li><a href=https://jakespiteri.co.uk/portfolio/ title=/portfolio><span>/portfolio</span></a></li><li><a href=https://jakespiteri.co.uk/blog/ title=/blog><span>/blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jakespiteri.co.uk/>Home</a>&nbsp;»&nbsp;<a href=https://jakespiteri.co.uk/portfolio/>Portfolio</a>&nbsp;»&nbsp;<a href=https://jakespiteri.co.uk/portfolio/computing-1/>Statistical Computing 1</a></div><h1 class=post-title>Portfolio Report 1: An Introduction to R</h1><div class=post-meta>Jake Spiteri&nbsp;|&nbsp;<a href=https://github.com/jakespiteri/jakespiteri.github.io/tree/master/portfolio/computing-1/Report-1/index.html rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>R is a high-level programming language widely used for statistical computing. Base R provides users with a large variety of statistical and graphical tools, which are easily extended via the use of packages.</p><p>R is an <a href=https://en.wikipedia.org/wiki/Interpreted_language>interpreted programming language</a>. This means that R users execute code via a command-line interpreter and code is interpreted into low-level instructions one line at a time. Integrated development environments (IDEs) such as <a href=https://rstudio.com/>RStudio</a> provide easy access to such an interpreter through the use of a console. Interpreted languages are looked at in more depth in a later report, but it is important to note that interpreted languages such a R are slow in comparison to compiled languages. Due to this, a majority of the base R code is written in low-level compiled languages — approximately 50% of the base R code is written in C/C++, 30% in Fortran, and 20% in R.</p><div id=how-to-run-r-code class="section level2"><h2>How to run R code</h2><p>There are many ways that we can work with R. We can work directly from a terminal, in which we can interactively input commands which are then interpreted as R code, or we can directly run an R script in the terminal (a text file with extension ‘.R’). Once R is installed one can initialize a session in the terminal by simply typing <code>R</code>, and we can run an R script with the command <code>Rscript path/to/Rscript</code>. Running lines of code in the terminal is useful for quickly testing ideas, but a script is preferred for analyses which require more thought as a script provides access to and stores all code that has been run.</p><p>We can improve our workflow by using an IDE such as RStudio. RStudio greatly improves upon the R coding experience in a number of ways:</p><ol style=list-style-type:decimal><li><p><strong>Panes</strong> — RStudio’s default interface consists of four ‘panes’ which provide access to a script window, console window, environment window, and a files/plots/help window. These panes are also <em>highly</em> customizable. Panes allow us to efficiently switch between writing a script, running code in the console, and viewing plots or function documentation.</p></li><li><p><strong>Text Editor</strong> — RStudio’s text editor provides many of the features you would expect from an IDE, such as syntax highlighting, code completion, and find and replace with regular expressions.</p></li><li><p><strong>Autocompletion</strong> — A particularly useful key in RStudio is the Tab key. When typing a function or object name, pressing the Tab key will autocomplete the name; once a function has been specified e.g. <code>lm()</code>, pressing the Tab key once more will list all of the possible arguments for the given function.</p></li></ol></div><div id=fundamentals class="section level2"><h2>Fundamentals</h2><p>We now look at some fundamentals of R programming. This will only be a brief introduction but should cover a wide-array of topics.</p><div id=variable-names-and-types class="section level3"><h3>Variable names and types</h3><p>In R a value can be assigned to a variable using the assignment operator <code>&lt;-</code>. It is possible to use <code>=</code> to assign a value to a variable, but it is not recommended. If the specified variable already exists, this will overwrite the existing variable. For example,</p><pre class=r><code>x &lt;- 1
x</code></pre><pre><code>## [1] 1</code></pre><pre class=r><code>x &lt;- 2
x</code></pre><pre><code>## [1] 2</code></pre><p>As seen above, simply assigning a variable does not produce an output. We can call the variable to implicitly print the variable’s value.</p><p>Variables in R can take on many different data types. These data types can be seen in Table 1 below.</p><p>As seen in the table we can also assign strings and logical values to variables.</p><pre class=r><code>x &lt;- &quot;hello world&quot;
x</code></pre><pre><code>## [1] &quot;hello world&quot;</code></pre><pre class=r><code>x &lt;- TRUE
x</code></pre><pre><code>## [1] TRUE</code></pre><p>A variable name can consist of letters, numbers, dots, and underscores.</p></div><div id=arithmetic class="section level3"><h3>Arithmetic</h3><p>As you would expect, R is capable of performing many operations. Some are shown below.</p><pre class=r><code># addition
1 + 1</code></pre><pre><code>## [1] 2</code></pre><pre class=r><code># subtraction
3 - 1</code></pre><pre><code>## [1] 2</code></pre><pre class=r><code># multiplication
1 * 2</code></pre><pre><code>## [1] 2</code></pre><pre class=r><code># division
6 / 3</code></pre><pre><code>## [1] 2</code></pre><pre class=r><code># exponentiation
2^2</code></pre><pre><code>## [1] 4</code></pre><pre class=r><code># integer division
5 %/% 2</code></pre><pre><code>## [1] 2</code></pre><pre class=r><code># integer modulus
7 %% 5</code></pre><pre><code>## [1] 2</code></pre><p>Of course, R implements the order of operations which we all know. We can change this behavior by using parentheses.</p><pre class=r><code>2 + 4 / 2 </code></pre><pre><code>## [1] 4</code></pre><pre class=r><code>(2 + 4) / 2</code></pre><pre><code>## [1] 3</code></pre></div><div id=conditional-statements class="section level3"><h3>Conditional Statements</h3><p>R can execute certain commands conditional upon a logical value by using <code>if/else</code> statements. These statements are commonly of the form</p><pre><code>if (&lt;logical value&gt;) {
  &lt;evaluate when logical value is TRUE&gt;
} else {
  &lt;evaluate when logical value is FALSE&gt;
}</code></pre><p>We can also nest <code>if</code> statements to obtain more complicated logic. A simple example is shown below.</p><pre class=r><code>x &lt;- TRUE
if (x) {
  print(&quot;x is TRUE&quot;)
} else {
  print(&quot;x is FALSE&quot;)
}</code></pre><pre><code>## [1] &quot;x is TRUE&quot;</code></pre><pre class=r><code>x &lt;- FALSE
if (x) {
  print(&quot;x is TRUE&quot;)
} else {
  print(&quot;x is FALSE&quot;)
}</code></pre><pre><code>## [1] &quot;x is FALSE&quot;</code></pre><p>The curly brackets are not always necessary but are always recommended in order to avoid bugs. For example</p><pre class=r><code># setup
x &lt;- 4

# brackets are not needed
if (x&lt;5) print(&quot;x is less than 5&quot;)</code></pre><pre><code>## [1] &quot;x is less than 5&quot;</code></pre><pre class=r><code># brackets are needed
if (x&gt;5) 
  print(&quot;nice&quot;)
  print(&quot;x is more than five&quot;)</code></pre><pre><code>## [1] &quot;x is more than five&quot;</code></pre><p>The logical value for the last <code>if</code> loop is <code>FALSE</code>, so we would expect nothing to be printed. The error occurs because the last <code>if</code> statement is equivalent to</p><pre class=r><code>if (x&gt;5) {
  print(&quot;nice&quot;)
}
print(&quot;x is more than five&quot;)</code></pre><pre><code>## [1] &quot;x is more than five&quot;</code></pre><p>Whereas what we actually wanted was</p><pre class=r><code>if (x&gt;5) {
  print(&quot;nice&quot;)
  print(&quot;x is more than five&quot;)
}</code></pre></div><div id=relational-and-logical-operators class="section level3"><h3>Relational and logical operators</h3>We often want to generate a <code>TRUE</code> or <code>FALSE</code> value dependent on some variables, like the <code>x &lt; 5</code> seen above. The relational operators are
We may want to combine logical values using logical operators. The logical operators can be found in Table 3 below.</div><div id=functions class="section level3"><h3>Functions</h3><p>We can easily create functions in R. Functions allow us to simplify our code by putting repeated computations into a function. The syntax used to create a function is</p><pre><code>&lt;function_name&gt; &lt;- function(&lt;arguments&gt;) {
  &lt;computation&gt;
}</code></pre><p>For example, suppose we wanted to easily find the <span class="math inline">\(p\)</span>-norm of a vector.</p><pre class=r><code>lp_norm &lt;- function(x, p) {
  norm &lt;- sum(abs(x)^p)^(1/p)
  return(norm)
}

# l1 norm
lp_norm(c(-1,1), p=1) # should be 2</code></pre><pre><code>## [1] 2</code></pre><pre class=r><code># l2 norm
lp_norm(c(3,4), p=2) # should be 5</code></pre><pre><code>## [1] 5</code></pre><p>It is good practice to <code>return</code> the final argument you want to output.</p></div><div id=data-structures-vectors-matrices-and-lists class="section level3"><h3>Data structures: vectors, matrices, and lists</h3>There are many data structures that we frequently use in R. Below is a table categorizing some of the most common. Some structures are homogeneous in that every element within them has the same data type, and some are heterogeneous in that their elements can be of different types.<p>Below we generate some of the above data structures.</p><pre class=r><code>## vectors
# generate sequence from 1 to 10
x &lt;- 1:10
print(x)</code></pre><pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre><pre class=r><code># get the length of x
length(x)</code></pre><pre><code>## [1] 10</code></pre><pre class=r><code># get the data type of x
typeof(x)</code></pre><pre><code>## [1] &quot;integer&quot;</code></pre><pre class=r><code># generate new x of type
x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
print(x)</code></pre><pre><code>## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre><pre class=r><code># get the data type of x
typeof(x)</code></pre><pre><code>## [1] &quot;character&quot;</code></pre><pre class=r><code># index into x
x[1]</code></pre><pre><code>## [1] &quot;a&quot;</code></pre><pre class=r><code># reassign an index
x[2] &lt;- &quot;d&quot;
print(x)</code></pre><pre><code>## [1] &quot;a&quot; &quot;d&quot; &quot;c&quot;</code></pre><pre class=r><code># we cannot change the data type
# below we try to input a numeric 1, but R inputs a STRING &quot;1&quot; 
x[2] &lt;- as.numeric(1)
print(x)</code></pre><pre><code>## [1] &quot;a&quot; &quot;1&quot; &quot;c&quot;</code></pre><pre class=r><code>typeof(x[2])</code></pre><pre><code>## [1] &quot;character&quot;</code></pre><pre class=r><code>## matrices
# generate a matrix
x &lt;- matrix(c(1, 0, 0, 1), 2, 2)
x</code></pre><pre><code>##      [,1] [,2]
## [1,]    1    0
## [2,]    0    1</code></pre><pre class=r><code># check dimensions
dim(x)</code></pre><pre><code>## [1] 2 2</code></pre><pre class=r><code># get first row of x
x[1, ]</code></pre><pre><code>## [1] 1 0</code></pre><pre class=r><code># assign colnames
colnames(x) &lt;- c(&quot;column 1&quot;, &quot;column 2&quot;)
x</code></pre><pre><code>##      column 1 column 2
## [1,]        1        0
## [2,]        0        1</code></pre><pre class=r><code># check type of elements
typeof(x)</code></pre><pre><code>## [1] &quot;double&quot;</code></pre><pre class=r><code># many R functions can be applied elementwise
sin(x)</code></pre><pre><code>##      column 1 column 2
## [1,] 0.841471 0.000000
## [2,] 0.000000 0.841471</code></pre><pre class=r><code>max(x)</code></pre><pre><code>## [1] 1</code></pre><pre class=r><code># try to input a string as the top left entry
x[1,1] &lt;- &quot;test&quot;
x</code></pre><pre><code>##      column 1 column 2
## [1,] &quot;test&quot;   &quot;0&quot;     
## [2,] &quot;0&quot;      &quot;1&quot;</code></pre><pre class=r><code># we have successfully replaced the [1,1] element but the data type 
# of every entry has changed
typeof(x)</code></pre><pre><code>## [1] &quot;character&quot;</code></pre><pre class=r><code># what happens if we try to find the maximum value now
max(x)</code></pre><pre><code>## [1] &quot;test&quot;</code></pre><pre class=r><code>## lists
# generate a list
x &lt;- list(numbers = c(1, 2, 3), letters = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))
x</code></pre><pre><code>## $numbers
## [1] 1 2 3
## 
## $letters
## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre><pre class=r><code># index into a list using $
x$numbers </code></pre><pre><code>## [1] 1 2 3</code></pre><pre class=r><code># index into a list using [[ ]]
x[[1]]</code></pre><pre><code>## [1] 1 2 3</code></pre><pre class=r><code># index into a vector in a list
x[[1]][1]</code></pre><pre><code>## [1] 1</code></pre><pre class=r><code># create new entries in a list on the fly
x$letters_backwards &lt;- rev(x$letters)
x</code></pre><pre><code>## $numbers
## [1] 1 2 3
## 
## $letters
## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;
## 
## $letters_backwards
## [1] &quot;c&quot; &quot;b&quot; &quot;a&quot;</code></pre><pre class=r><code># reformat a name in a list
names(x)[3] &lt;- &quot;letters backwards&quot;
x</code></pre><pre><code>## $numbers
## [1] 1 2 3
## 
## $letters
## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;
## 
## $`letters backwards`
## [1] &quot;c&quot; &quot;b&quot; &quot;a&quot;</code></pre><pre class=r><code># check the type of x
typeof(x)</code></pre><pre><code>## [1] &quot;list&quot;</code></pre><pre class=r><code># check the type of a named vector in x
typeof(x$numbers)</code></pre><pre><code>## [1] &quot;double&quot;</code></pre><pre class=r><code># lists can even contain functions
x &lt;- list()
x$eval &lt;- function(x, y) {
  return(x*y)
}

# use function
x$eval(2, 2)</code></pre><pre><code>## [1] 4</code></pre></div><div id=lexical-scoping class="section level3"><h3>Lexical scoping</h3><p>R uses <a href=http://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope_vs._dynamic_scope>lexical scoping</a>, which determines how a free variable within a function obtains a value. Consider the following function:</p><pre class=r><code>m &lt;- function(x) {
  return(x * y)
}</code></pre><p>This function has only one argument <code>x</code>. The function also requires another variable <code>y</code> which has not been defined locally in the function and is not given as a formal argument — this is called a <em>free variable</em>. The scoping rules implemented by a language determine how such a free variable obtains its value.</p><p>Lexical scoping means that the values of free variables are searched for in the environment in which the function was defined. If they are not found here, then R searches for their value in the parent environment. After reaching the top-level environment, R will look down the search list (found using <code>search()</code>). If R arrives at the empty environment without finding values for free variables, we will get an error.</p><p>Let’s implement the lp-norm again and demonstrate lexical scoping.</p><pre class=r><code># create a constructor function
make_lp_norm &lt;- function(p) {
  norm &lt;- function(x) {
    return(sum(abs(x)^p)^(1/p))
  }
  return(norm)
}

# use constructor to make l1 norm function
l1_norm &lt;- make_lp_norm(1)
l1_norm(c(1,1)) # should be 2</code></pre><pre><code>## [1] 2</code></pre><p>Let’s look at the code for <code>l1_norm</code>.</p><pre class=r><code>l1_norm</code></pre><pre><code>## function(x) {
##     return(sum(abs(x)^p)^(1/p))
##   }
## &lt;environment: 0x5572bbe5fc38&gt;</code></pre><p>We see that it depends on a free variable <code>p</code>. Recall that the value of the free variable is obtained from the environment in which the function was defined. In this case, <code>p</code> is equal to 1. Let’s check this by exploring the environment of the <code>l1_norm</code>.</p><pre class=r><code># list objects in l1_norm&#39;s environment
ls(environment(l1_norm))</code></pre><pre><code>## [1] &quot;norm&quot; &quot;p&quot;</code></pre><pre class=r><code>get(&quot;p&quot;, environment(l1_norm))</code></pre><pre><code>## [1] 1</code></pre><p>A simpler example would be to define a variable in the global environment, and then use it in a function.</p><pre class=r><code>n &lt;- 2
square &lt;- function(x) {
  return(x^n)
}

# test the square function
square(2)</code></pre><pre><code>## [1] 4</code></pre><pre class=r><code>square(3)</code></pre><pre><code>## [1] 9</code></pre><p>A problem occurs when we expect a variable to be defined within a function, but it is defined in the global environment. Continuing with the above example, it seems plausible that we may reassign the value of <code>n</code> at some point in our analyses.</p><pre class=r><code># reassign n
n &lt;- 3

# the square function no longer works as expected
square(2)</code></pre><pre><code>## [1] 8</code></pre></div></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://jakespiteri.co.uk/portfolio/computing-1/report-2/><span class=title>Next »</span><br><span>Portfolio Report 2: Reproducibility</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://jakespiteri.co.uk/>Jake Spiteri</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>