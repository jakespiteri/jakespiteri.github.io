<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Portfolio Report 3: Projects, version control, and packages | Jake Spiteri</title><meta name=keywords content><meta name=description content="R makes it relatively easy to structure a project, by creating a “project”. It also integrates git and github which makes it easy to track changes and publish code to the web.
Projects: organizing code The best way to approach projects is to maintain a well-defined file structure. RStudio projects allow you to easily divide your work into different directories. Of course, this can be done manually. Generally a good high-level file structure within your project’s directory is:"><meta name=author content="Jake Spiteri"><link rel=canonical href=https://jakespiteri.co.uk/portfolio/computing-1/report-3/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jakespiteri.co.uk/favi.png><link rel=icon type=image/png sizes=16x16 href=https://jakespiteri.co.uk/favi.png><link rel=icon type=image/png sizes=32x32 href=https://jakespiteri.co.uk/favi.png><link rel=apple-touch-icon href=https://jakespiteri.co.uk/favi.png><link rel=mask-icon href=https://jakespiteri.co.uk/favi.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Portfolio Report 3: Projects, version control, and packages"><meta property="og:description" content="R makes it relatively easy to structure a project, by creating a “project”. It also integrates git and github which makes it easy to track changes and publish code to the web.
Projects: organizing code The best way to approach projects is to maintain a well-defined file structure. RStudio projects allow you to easily divide your work into different directories. Of course, this can be done manually. Generally a good high-level file structure within your project’s directory is:"><meta property="og:type" content="article"><meta property="og:url" content="https://jakespiteri.co.uk/portfolio/computing-1/report-3/"><meta property="og:image" content="https://jakespiteri.co.uk/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="portfolio"><meta property="og:site_name" content="Jake Spiteri"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jakespiteri.co.uk/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Portfolio Report 3: Projects, version control, and packages"><meta name=twitter:description content="R makes it relatively easy to structure a project, by creating a “project”. It also integrates git and github which makes it easy to track changes and publish code to the web.
Projects: organizing code The best way to approach projects is to maintain a well-defined file structure. RStudio projects allow you to easily divide your work into different directories. Of course, this can be done manually. Generally a good high-level file structure within your project’s directory is:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Portfolio","item":"https://jakespiteri.co.uk/portfolio/"},{"@type":"ListItem","position":2,"name":"Statistical Computing 1","item":"https://jakespiteri.co.uk/portfolio/computing-1/"},{"@type":"ListItem","position":3,"name":"Portfolio Report 3: Projects, version control, and packages","item":"https://jakespiteri.co.uk/portfolio/computing-1/report-3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Portfolio Report 3: Projects, version control, and packages","name":"Portfolio Report 3: Projects, version control, and packages","description":"R makes it relatively easy to structure a project, by creating a “project”. It also integrates git and github which makes it easy to track changes and publish code to the web.\nProjects: organizing code The best way to approach projects is to maintain a well-defined file structure. RStudio projects allow you to easily divide your work into different directories. Of course, this can be done manually. Generally a good high-level file structure within your project’s directory is:","keywords":[],"articleBody":" R makes it relatively easy to structure a project, by creating a “project”. It also integrates git and github which makes it easy to track changes and publish code to the web.\nProjects: organizing code The best way to approach projects is to maintain a well-defined file structure. RStudio projects allow you to easily divide your work into different directories. Of course, this can be done manually. Generally a good high-level file structure within your project’s directory is:\nR/ — Contains all of the project’s R scripts. It is best to not divide these files into subdirectories. README.md — A markdown document describing the project. data/ — Contains the data used for the project. It may be split into subdirectories raw/ and processed/. doc/ — Contains the documentation for the project. If implementing a method, an academic paper detailing the method may be found here. output/ — The output(s) produced by applying the R scripts in R/ to the data. The outputs may be divided into subdirectories; all plots may be in a figures/ folder for example. tests/ — Contains R scripts which test the functions developed in the package. It is best practice to produce test functions which check that functions work as expected. These functions can also be run every time code is changed, so the author is aware when functionality breaks. Version control with git and GitHub A version control system that keeps track of the changes made to a set of documents. Each time we track a change, it creates a snapshot of our files which we can revert back to at any point in time. Many of us make copies of our files and store multiple versions of them. Version control systems such as git make this process extremely easy and less prone to errors.\nGit Setup Once git is installed, it will be useful to set your identity as a global configuration parameter. These parameters can be set for specified git repositories, or globally.\nTo set your name and email address, use the following commands in the terminal.\ngit config --global user.name \"Your Name\" git config --global user.email name@domain.co.uk We can always check the global configuration using the following commands:\ngit config --list --show-origin Otherwise, we can directly view the global parameters using the following\ngit config --global Initializing a git repository We can easily use git to start tracking changes within a directory. Simply navigate to the top-level folder for which you want to track changes in, and type\ngit init The subdirectory will then become a fully-functional git repository. Before git starts to track files you must add them to the staging area.\nAdding files to the staging area A useful command before adding files to the staging area is git status. This will show the status of every file within your working directory: what files have been edited, moved, deleted, and which files are being tracked or not. It will also give some advice on how to add files to the staging area, how to discard changes in the current working tree, and how to unstage files.\nTo add a file to the staging area, use the command\ngit add Note that you can add entire subdirectories to the staging area using this command. You may encounter a situation in which you have staged a file you do not want to track. In this case you can remove said file from the staging area using\ngit reset HEAD Similarly to adding files to the staging area, you can unstage individual files or entire subdirectories. To remove everything from the staging area, simply use\ngit reset HEAD . Committing changes Once a file has been staged, we can commit the file using\ngit commit -m \"commit message\" It is good practice to commit only files which change a single piece of functionality, rather than commit all changes that have been made. It is also useful to add an informative commit message which explains what has changed. The commit saves the changes that have been made to the code, so we can return to a previous version of the code if necessary.\nReverting / Resetting Sometimes changes have been made locally which have not been commited, which break functionality. In such a case, we may want to revert to the last commit. To do this we can use\ngit revert HEAD We can think of this as undoing changes that have been made. It inverts the last commit and then appends a new commit with this inverted content. It is also important to note the difference between revert and reset. Firstly, git revert changes made in a single commit (this can be any commit in the repo’s history) whereas git reset returns the repo to a previous commit by removing all subsequent commits. So revert maintains the history of the repo by adding a new commit, and reset deletes some history by returning to a previous commit and deleting subsequent commits.\nCreating a branch When making substantial changes to an existing repo, it may be better to work on a different ‘branch’ of the project. We can then work on the branch without affecting the master branch.\nTo create a new git branch, we use the following\ngit branch To then switch to our new branch we use\ngit checkout This means we can easily switch between the master and existing branches. In order to merge the changes made in the new branch to the master, we switch to the master using git checkout master and then merge using git merge .\nIf there are conflicts, git will add comments to the files which will need to be manually addressed before merging.\nTo delete a branch simply use git branch -d .\nCheck out an old version You may want to return to an old version of your code. To do this we can get commit hashes using the log git log, and then checkout an old snapshot of the code using\ngit checkout -b Packages Similar to projects, RStudio also makes it easy to create packages. Within a package there are some necessary files such as\nDESCRIPTION — Provides details of who created the package, who maintains it, the version of R used etc. LICENSE — Details the license you have chosen for the package e.g. GPL-2, MIT+, etc. NAMESPACE R/ — A folder containing the package’s R scripts. man — A folder containing the documentation. tests — A folder containing scripts that test the package’s functionality. Description file The first thing you should do after creating a package is edit the DESCRIPTION file. The template provided by RStudio makes this pretty self explanatory. You should add the license, the title, and the author, etc.\nDocumentation A good package should be well documented. The package devtools and RStudio make documenting code straightforward. You can enable automatic documentation building in RStudio after installing the devtools package, by clicking Build -\u003e Configure Build Toolds... -\u003e Generate documentation with Roxygen.\nYou can also directly add documentation for functions in a package by right clicking the function and selecting Code -\u003e Insert Roxygen skeleton. You can describe the function’s features and parameters in the skeleton above the function, and this will be added to the help document for the function.\nTesting When developing a package it is useful to use a test suite to ensure that functionality doesn’t break during development. In order to test the functionality you must write test scripts that compare the output of a function to the expected output. Writing test scripts requires additional effort but they greatly simplify the development process. Testing ensures that the code has fewer bugs as we explicitly test the code’s behavior. Testing in RStudio can be done with the testthat package. Once this package is installed you should run\nusethis::testthat(\"\") This will create a new directory called tests in which you can add your test scripts. There should already be a test script in the folder called test-.R.\nOnce the test suite is set up the workflow is simple: We modify our code or tests, test the package by running devtools::test(), and fix any errors that have occurred.\nChapter 10 of the book R Packages is a great resource for writing test scripts. The book can be found here.\nCoverage When creating a package we want to develop a well-rounded test suite. It may be difficult to ensure that all of our code is covered by our tests — it seems plausible that there are some scenarios which should throw errors which have not been tested by a script. To mitigate this issue we can use tools that tell us which lines have been tested by our test suite. This is called code coverage. This is very easy to do in R using the package covr. Once installed we can test the coverage of a package by running\ncovr:report() The report provides a lot of useful information: which lines have been covered, which have not been covered, how many times a line is covered, etc. It will also tell us which percentage of the code is covered, and ideally we will strive for 100% coverage. This means that when new code is added to the package we will need to write new test scripts.\nExample An example R package using all of the tools described above can be found here.\n","wordCount":"1572","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Jake Spiteri"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jakespiteri.co.uk/portfolio/computing-1/report-3/"},"publisher":{"@type":"Organization","name":"Jake Spiteri","logo":{"@type":"ImageObject","url":"https://jakespiteri.co.uk/favi.png"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://jakespiteri.co.uk/ accesskey=h title="Home (Alt + H)"><img src=https://jakespiteri.co.uk/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://jakespiteri.co.uk/about/ title=/about><span>/about</span></a></li><li><a href=https://jakespiteri.co.uk/portfolio/ title=/portfolio><span>/portfolio</span></a></li><li><a href=https://jakespiteri.co.uk/blog/ title=/blog><span>/blog</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jakespiteri.co.uk/>Home</a>&nbsp;»&nbsp;<a href=https://jakespiteri.co.uk/portfolio/>Portfolio</a>&nbsp;»&nbsp;<a href=https://jakespiteri.co.uk/portfolio/computing-1/>Statistical Computing 1</a></div><h1 class=post-title>Portfolio Report 3: Projects, version control, and packages</h1><div class=post-meta>Jake Spiteri&nbsp;|&nbsp;<a href=https://github.com/jakespiteri/jakespiteri.github.io/tree/master/portfolio/computing-1/Report-3/index.html rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>R makes it relatively easy to structure a project, by creating a “project”. It also integrates git and github which makes it easy to track changes and publish code to the web.</p><div id=projects-organizing-code class="section level1"><h1>Projects: organizing code</h1><p>The best way to approach projects is to maintain a well-defined file structure. RStudio projects allow you to easily divide your work into different directories. Of course, this can be done manually. Generally a good high-level file structure within your project’s directory is:</p><ul><li><code>R/</code> — Contains all of the project’s R scripts. It is best to not divide these files into subdirectories.</li><li><code>README.md</code> — A markdown document describing the project.</li><li><code>data/</code> — Contains the data used for the project. It may be split into subdirectories <code>raw/</code> and <code>processed/</code>.</li><li><code>doc/</code> — Contains the documentation for the project. If implementing a method, an academic paper detailing the method may be found here.</li><li><code>output/</code> — The output(s) produced by applying the R scripts in <code>R/</code> to the data. The outputs may be divided into subdirectories; all plots may be in a <code>figures/</code> folder for example.</li><li><code>tests/</code> — Contains R scripts which test the functions developed in the package. It is best practice to produce test functions which check that functions work as expected. These functions can also be run every time code is changed, so the author is aware when functionality breaks.</li></ul></div><div id=version-control-with-git-and-github class="section level1"><h1>Version control with git and GitHub</h1><p>A version control system that keeps track of the changes made to a set of documents. Each time we track a change, it creates a snapshot of our files which we can revert back to at any point in time. Many of us make copies of our files and store multiple versions of them. Version control systems such as git make this process extremely easy and less prone to errors.</p></div><div id=git class="section level1"><h1>Git</h1><div id=setup class="section level2"><h2>Setup</h2><p>Once git is installed, it will be useful to set your identity as a global configuration parameter. These parameters can be set for specified git repositories, or globally.</p><p>To set your name and email address, use the following commands in the terminal.</p><pre><code>git config --global user.name &quot;Your Name&quot;
git config --global user.email name@domain.co.uk</code></pre><p>We can always check the global configuration using the following commands:</p><pre><code>git config --list --show-origin</code></pre><p>Otherwise, we can directly view the global parameters using the following</p><pre><code>git config --global &lt;parameter&gt;</code></pre></div><div id=initializing-a-git-repository class="section level2"><h2>Initializing a git repository</h2><p>We can easily use git to start tracking changes within a directory. Simply navigate to the top-level folder for which you want to track changes in, and type</p><pre><code>git init</code></pre><p>The subdirectory will then become a fully-functional git repository. Before git starts to track files you must add them to the staging area.</p></div><div id=adding-files-to-the-staging-area class="section level2"><h2>Adding files to the staging area</h2><p>A useful command before adding files to the staging area is <code>git status</code>. This will show the status of every file within your working directory: what files have been edited, moved, deleted, and which files are being tracked or not. It will also give some advice on how to add files to the staging area, how to discard changes in the current working tree, and how to unstage files.</p><p>To add a file to the staging area, use the command</p><pre><code>git add &lt;filename&gt;</code></pre><p>Note that you can add entire subdirectories to the staging area using this command. You may encounter a situation in which you have staged a file you do not want to track. In this case you can remove said file from the staging area using</p><pre><code>git reset HEAD &lt;filename&gt;</code></pre><p>Similarly to adding files to the staging area, you can unstage individual files or entire subdirectories. To remove everything from the staging area, simply use</p><pre><code>git reset HEAD .</code></pre></div><div id=committing-changes class="section level2"><h2>Committing changes</h2><p>Once a file has been staged, we can commit the file using</p><pre><code>git commit -m &quot;commit message&quot;</code></pre><p>It is good practice to commit only files which change a single piece of functionality, rather than commit <em>all</em> changes that have been made. It is also useful to add an informative commit message which explains what has changed. The commit saves the changes that have been made to the code, so we can return to a previous version of the code if necessary.</p></div><div id=reverting-resetting class="section level2"><h2>Reverting / Resetting</h2><p>Sometimes changes have been made locally which have not been commited, which break functionality. In such a case, we may want to revert to the last commit. To do this we can use</p><pre><code>git revert HEAD</code></pre><p>We can think of this as undoing changes that have been made. It inverts the last commit and then appends a new commit with this inverted content. It is also important to note the difference between <code>revert</code> and <code>reset</code>. Firstly, <code>git revert</code> changes made in a single commit (this can be <em>any</em> commit in the repo’s history) whereas <code>git reset</code> returns the repo to a previous commit by <em>removing</em> all subsequent commits. So <code>revert</code> maintains the history of the repo by adding a new commit, and <code>reset</code> <em>deletes</em> some history by returning to a previous commit and deleting subsequent commits.</p></div><div id=creating-a-branch class="section level2"><h2>Creating a branch</h2><p>When making substantial changes to an existing repo, it may be better to work on a different ‘branch’ of the project. We can then work on the branch without affecting the master branch.</p><p>To create a new git branch, we use the following</p><pre><code>git branch &lt;branch-name&gt;</code></pre><p>To then switch to our new branch we use</p><pre><code>git checkout &lt;branch-name&gt;</code></pre><p>This means we can easily switch between the master and existing branches. In order to merge the changes made in the new branch to the master, we switch to the master using <code>git checkout master</code> and then merge using <code>git merge &lt;branch-name></code>.</p><p>If there are conflicts, git will add comments to the files which will need to be manually addressed before merging.</p><p>To delete a branch simply use <code>git branch -d &lt;branch-name></code>.</p></div><div id=check-out-an-old-version class="section level2"><h2>Check out an old version</h2><p>You may want to return to an old version of your code. To do this we can get commit hashes using the log <code>git log</code>, and then checkout an old snapshot of the code using</p><pre><code>git checkout &lt;commit hash&gt; -b &lt;branch-name&gt;</code></pre></div></div><div id=packages class="section level1"><h1>Packages</h1><p>Similar to projects, RStudio also makes it easy to create packages. Within a package there are some necessary files such as</p><ul><li><code>DESCRIPTION</code> — Provides details of who created the package, who maintains it, the version of R used etc.</li><li><code>LICENSE</code> — Details the license you have chosen for the package e.g. GPL-2, MIT+, etc.</li><li><code>NAMESPACE</code></li><li><code>R/</code> — A folder containing the package’s R scripts.</li><li><code>man</code> — A folder containing the documentation.</li><li><code>tests</code> — A folder containing scripts that test the package’s functionality.</li></ul><div id=description-file class="section level2"><h2>Description file</h2><p>The first thing you should do after creating a package is edit the DESCRIPTION file. The template provided by RStudio makes this pretty self explanatory. You should add the license, the title, and the author, etc.</p></div><div id=documentation class="section level2"><h2>Documentation</h2><p>A good package should be well documented. The package <code>devtools</code> and RStudio make documenting code straightforward. You can enable automatic documentation building in RStudio after installing the <code>devtools</code> package, by clicking <code>Build -> Configure Build Toolds... -> Generate documentation with Roxygen</code>.</p><p>You can also directly add documentation for functions in a package by right clicking the function and selecting <code>Code -> Insert Roxygen skeleton</code>. You can describe the function’s features and parameters in the skeleton above the function, and this will be added to the help document for the function.</p></div><div id=testing class="section level2"><h2>Testing</h2><p>When developing a package it is useful to use a test suite to ensure that functionality doesn’t break during development. In order to test the functionality you must write test scripts that compare the output of a function to the expected output. Writing test scripts requires additional effort but they greatly simplify the development process. Testing ensures that the code has fewer bugs as we explicitly test the code’s behavior.
Testing in RStudio can be done with the <code>testthat</code> package. Once this package is installed you should run</p><pre><code>usethis::testthat(&quot;&lt;name&gt;&quot;)</code></pre><p>This will create a new directory called <code>tests</code> in which you can add your test scripts. There should already be a test script in the folder called <code>test-&lt;name>.R</code>.</p><p>Once the test suite is set up the workflow is simple: We modify our code or tests, test the package by running <code>devtools::test()</code>, and fix any errors that have occurred.</p><p>Chapter 10 of the book R Packages is a great resource for writing test scripts. The book can be found <a href=https://r-pkgs.org/>here</a>.</p></div><div id=coverage class="section level2"><h2>Coverage</h2><p>When creating a package we want to develop a well-rounded test suite. It may be difficult to ensure that all of our code is covered by our tests — it seems plausible that there are some scenarios which should throw errors which have not been tested by a script.
To mitigate this issue we can use tools that tell us which lines have been tested by our test suite. This is called <em>code coverage</em>. This is very easy to do in R using the package <code>covr</code>. Once installed we can test the coverage of a package by running</p><pre><code>covr:report()</code></pre><p>The report provides a lot of useful information: which lines have been covered, which have not been covered, how many times a line is covered, etc. It will also tell us which percentage of the code is covered, and ideally we will strive for 100% coverage. This means that when new code is added to the package we will need to write new test scripts.</p></div></div><div id=example class="section level1"><h1>Example</h1><p>An example R package using all of the tools described above can be found <a href=https://github.com/jakespiteri/vectools-travis/>here</a>.</p></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://jakespiteri.co.uk/portfolio/computing-1/report-2/><span class=title>« Prev</span><br><span>Portfolio Report 2: Reproducibility</span></a>
<a class=next href=https://jakespiteri.co.uk/portfolio/computing-1/report-4/><span class=title>Next »</span><br><span>Portfolio Report 4: Vectorization and parallel computing</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://jakespiteri.co.uk/>Jake Spiteri</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>